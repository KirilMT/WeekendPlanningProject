<!DOCTYPE html>
<html>
<head>
    <title>Technician Dashboard</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            overflow-x: hidden;
        }
        h1, h2 {
            text-align: center;
            color: #333;
            font-weight: 500;
        }
        .task-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-bottom: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        .task-table th {
            background-color: #e3f2fd;
            font-weight: 600;
            color: #333;
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .task-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            color: #333;
        }
        .task-table tr:last-child td {
            border-bottom: none;
        }
        .prio-a { background-color: #ff4d4d; color: #333; }
        .prio-b { background-color: #ffd700; color: #333; }
        .prio-c { background-color: #d2b48c; color: #333; }

        .gantt-container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            box-sizing: border-box;
            overflow: hidden; /* Important for overall container */
        }

        .gantt-chart {
            position: relative;
            display: flex; /* CHANGED: to arrange left and right panes */
            min-height: 0; /* For flexbox to behave in scrollable content */
            /* Removed overflow-x, overflow-y, flex-direction: column */
        }

        /* New Styles for Panes */
        .gantt-fixed-left-pane {
            width: 200px;
            flex-shrink: 0; /* Prevent shrinking */
            position: relative;
            z-index: 20;
            background-color: #fff; /* Match page background or a specific pane background */
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ccc; /* Vertical separator line */
        }

        .gantt-scrollable-right-pane {
            flex-grow: 1; /* Take remaining space */
            overflow-x: auto; /* THIS IS THE TARGET HORIZONTAL SCROLLBAR */
            overflow-y: auto; /* THIS IS THE PRIMARY VERTICAL SCROLLBAR */
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* Common styles for axis containers (now on 4 new wrappers) */
        .axis-container {
            display: grid;
            position: sticky;
            background-color: #fff; /* Ensure background for sticky headers */
            /* z-index will be set more specifically on child wrappers */
        }
        .axis-container::after { /* Bottom border for the entire axis row */
            content: "";
            display: block;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            border-bottom: 1px solid #ddd;
        }

        /* Spacer Axis Wrappers (Left Pane) */
        .clock-time-axis-spacer-wrapper {
            height: 25px;
            top: 0;
            z-index: 22; /* Above technician labels and right pane headers */
        }
        .work-interval-axis-spacer-wrapper {
            height: 30px;
            top: 25px; /* Stick below the clock-time-axis-spacer-wrapper */
            z-index: 22;
        }

        /* Ticks Axis Wrappers (Right Pane) */
        .clock-time-axis-ticks-wrapper {
            height: 25px;
            top: 0;
            z-index: 15; /* Above time-grids in right pane */
        }
        .work-interval-axis-ticks-wrapper {
            height: 30px;
            top: 25px; /* Stick below the clock-time-axis-ticks-wrapper */
            z-index: 15;
        }


        /* Technician Labels Wrapper (Left Pane) */
        .technician-labels-wrapper {
            flex-grow: 1; /* Allows it to fill vertical space */
            overflow-y: hidden; /* Vertical scroll will be synced from right pane */
            position: relative;
            background-color: #f9f9f9; /* Match technician label background */
        }

        .technician-label {
            width: 100%; /* Takes full width of its 200px parent column in the wrapper grid */
            height: 40px;
            font-weight: 500;
            color: #333;
            padding: 0 10px;
            box-sizing: border-box;
            background-color: #f9f9f9; /* Match wrapper or specific color */
            text-align: left;
            word-wrap: break-word;
            display: flex;
            align-items: center;
            /* border-right: 1px solid #ccc; */ /* Moved to .gantt-fixed-left-pane */
            border-bottom: 1px solid #ccc;
            /* position: sticky, left: 0, z-index REMOVED */
        }

        /* Time Grids Wrapper (Right Pane) */
        .time-grids-wrapper {
            flex-grow: 1;
            position: relative;
        }

        .time-grid {
            display: grid;
            grid-template-rows: 40px;
            grid-auto-rows: 0;
            position: relative;
            height: 40px;
            background: transparent;
            border-bottom: 1px solid #ccc;
            box-sizing: border-box;
        }


        .time-tick {
            text-align: center;
            font-size: 12px;
            color: #666;
            padding: 5px 2px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            white-space: nowrap;
            /* border-bottom: 1px solid #ddd; */ /* REMOVED: .axis-container::after handles this */
            /* border-right is applied by JS */
        }

        .time-tick.spacer-tick {
            /* width: 200px; */ /* Handled by grid column of its wrapper */
            background-color: #f9f9f9; /* Match technician label background */
            /* border-right: 1px solid #ccc; */ /* This is effectively the right border of the fixed pane */
            border-bottom: none; /* Crucial: No bottom border for the spacer tick itself */
            /* position: sticky, left: 0, z-index REMOVED */
        }
        /* Ensure the spacer tick in the fixed left pane doesn't get a right border from JS if JS adds it to all ticks */
        .gantt-fixed-left-pane .time-tick.spacer-tick {
            border-right: none !important; /* Override JS if it adds one */
        }


        /* Styles for break column fills in the content grid */
        .break-column-fill {
            grid-row: 1 / 2;
            height: 100%;
            z-index: 0;
        }
        .break-column-fill.break-type-break1,
        .break-column-fill.break-type-break2 {
            background-color: #dcdcdc;
        }
        .break-column-fill.break-type-breakMain {
            background-color: #c0c0c0;
        }
        .work-column-border-carrier {
            grid-row: 1 / 2;
            height: 100%;
            z-index: 0;
        }


        .task-bar {
            grid-row: 1 / 2;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            box-sizing: border-box;
            overflow: visible;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
            margin: 8px 2px;
            position: relative;
            z-index: 1;
        }
        .task-bar.zero-duration {
            width: 6px !important;
            min-width: 6px !important;
            height: 30px;
            margin-top: 5px;
            margin-bottom: 5px;
            border-radius: 1px;
            justify-self: center;
            padding: 0;
        }
        .task-bar.zero-duration span {
            display: none;
        }

        .task-segment-ends-before-break {
            margin-right: 4px;
        }
        .task-segment-ends-before-break::after {
            content: '';
            position: absolute;
            right: -5px;
            top: 0;
            bottom: 0;
            width: 5px;
            background:
                linear-gradient(135deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%),
                linear-gradient(45deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%);
            background-size: 10px 10px;
            background-repeat: repeat-y;
        }

        .task-segment-starts-after-break {
            margin-left: 4px;
        }
        .task-segment-starts-after-break::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 0;
            bottom: 0;
            width: 5px;
            background:
                linear-gradient(135deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%),
                linear-gradient(45deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%);
            background-size: 10px 10px;
            background-repeat: repeat-y;
            transform: scaleX(-1);
        }
        .task-bar span {
            position: relative;
            z-index: 1;
        }

        .time-tick.break-interval {
            background-color: #e7e7e7;
            font-style: italic;
            color: #555;
        }
        .time-tick.break-interval.break-type-break1,
        .time-tick.break-interval.break-type-break2 {
            background-color: #dcdcdc;
        }
        .time-tick.break-interval.break-type-breakMain {
            background-color: #c0c0c0;
        }

        /* --- START: CSS for Task Table (existing styles) --- */
        .task-table tr:not(.section-header):not(.task-row-rep):hover td:not(.prio-a):not(.prio-b):not(.prio-c) {
            background-color: #e9e9e9;
        }
        .task-table tr.section-header td {
            background-color: #d3d3d3;
            text-align: left;
            font-weight: bold;
            padding: 8px 16px;
        }
        .task-table tr.task-row-rep td {
            background-color: #e6e6e6;
        }
        .task-table tr.task-row-rep td.prio-a { background-color: #ff4d4d; color: #333; }
        .task-table tr.task-row-rep td.prio-b { background-color: #ffd700; color: #333; }
        .task-table tr.task-row-rep td.prio-c { background-color: #d2b48c; color: #333; }
        .task-table tr.task-row-rep:hover td:not(.prio-a):not(.prio-b):not(.prio-c) {
            background-color: #d1d1d1;
        }
        .task-table tr:hover td.prio-a { background-color: #ff4d4d; color: #333; }
        .task-table tr:hover td.prio-b { background-color: #ffd700; color: #333; }
        .task-table tr:hover td.prio-c { background-color: #d2b48c; color: #333; }
        /* --- END: CSS for Task Table --- */

    </style>
</head>
<body>
    <h1>Technician Dashboard</h1>

    <!-- Task Table -->
    <table class="task-table" border="1">
        <thead>
            <tr>
                <th>Index</th>
                <th>Tasks</th>
                <th>Lines</th>
                <th>Technicians</th>
                <th>Assigned Technicians (prio index)</th>
                <th>Time [min]</th>
                <th>Prio</th>
                <th>Qty</th>
                <th>Ticket/MO</th>
            </tr>
        </thead>
        <tbody>
            {% set pm_tasks = tasks | selectattr('task_type', 'equalto', 'PM') | list %}
            {% set rep_tasks = tasks | selectattr('task_type', 'equalto', 'REP') | list %}

            <!-- PM Section -->
            {% if pm_tasks %}
            <tr class="section-header">
                <td colspan="9">
                    PMs & PdMs
                </td>
            </tr>
            {% for task in pm_tasks %}
            <tr>
                <td class="index-cell" style="background-color: #{{ '%02x%02x%02x' % ((task.id | int | default(1)) * 97 % 200 + 55, (task.id | int | default(1)) * 53 % 200 + 55, (task.id | int | default(1)) * 37 % 200 + 55) }}; color: #fff;">
                    {{ task.id }}
                </td>
                <td>
                    {{ task.name }}
                    {% set unassigned_instance_details = [] %}
                    {% set incomplete_instances_list = [] %}
                    {% for i in range(task.quantity | int | default(1)) %}
                        {% set current_instance_id = task.id ~ '_' ~ (i + 1) %}
                        {% if unassigned_tasks and current_instance_id in unassigned_tasks %}
                            {% set _ = unassigned_instance_details.append({'num': i + 1, 'reason': unassigned_tasks[current_instance_id]}) %}
                        {% endif %}
                        {% if incomplete_tasks and current_instance_id in incomplete_tasks %}
                            {% set _ = incomplete_instances_list.append(i + 1) %}
                        {% endif %}
                    {% endfor %}
                    {% if unassigned_instance_details %}
                        {% set unassigned_numbers = unassigned_instance_details | map(attribute='num') | list %}
                        {% set unassigned_reasons_tooltip_lines = [] %}
                        {% for detail in unassigned_instance_details %}
                            {% set _ = unassigned_reasons_tooltip_lines.append("Instance " ~ detail.num ~ ": " ~ detail.reason) %}
                        {% endfor %}
                        <br><span style="color: red; font-size: 0.9em;" title="{{ unassigned_reasons_tooltip_lines | join('\n') }}">
                            Unassigned: {{ unassigned_numbers | join(', ') }}
                        </span>
                    {% endif %}
                    {% if incomplete_instances_list %}
                        <br><span style="color: orange; font-size: 0.9em;" title="Instances {{ incomplete_instances_list | join(', ') }} were partially assigned due to shift end.">
                            Partially Assigned: {{ incomplete_instances_list | join(', ') }}
                        </span>
                    {% endif %}
                </td>
                <td>
                    {% if task.lines is none or task.lines == 'nan' or task.lines == '' %}
                        N/A
                    {% else %}
                        {{ task.lines }}
                    {% endif %}
                </td>
                <td>{{ task.mitarbeiter_pro_aufgabe | default('1') }}</td>
                <td>
                    {% set tech_assignments_for_task = {} %}
                    {% if assignments %}
                        {% for assignment in assignments %}
                            {% if assignment.instance_id.startswith(task.id ~ '_') %}
                                {% if assignment.technician not in tech_assignments_for_task %}
                                    {% set _ = tech_assignments_for_task.update({assignment.technician: assignment.get('technician_task_priority', 'N/A')}) %}
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}
                    {% set assigned_tech_details = [] %}
                    {% for tech_name, tech_prio in tech_assignments_for_task.items() | sort %}
                        {% set _ = assigned_tech_details.append("%s (%s)" | format(tech_name, tech_prio)) %}
                    {% endfor %}
                    {{ assigned_tech_details | join(', ') if assigned_tech_details else 'None' }}
                </td>
                <td>{{ task.planned_worktime_min | default('0') }}</td>
                <td class="{% if task.priority == 'A' %}prio-a{% elif task.priority == 'B' %}prio-b{% elif task.priority == 'C' %}prio-c{% else %}prio-c{% endif %}">
                    {{ task.priority | default('C')}}
                </td>
                <td>{{ task.quantity | default('1') }}</td>
                <td>
                    {% if task.task_type.upper() == 'REP' and task.ticket_mo and task.ticket_mo != 'nan' %}
                        {% if task.ticket_url %}
                            <a href="{{ task.ticket_url }}" target="_blank">{{ task.ticket_mo }}</a>
                        {% else %}
                            {{ task.ticket_mo }}
                        {% endif %}
                    {% elif task.task_type.upper() == 'PM' %}
                        {% set encoded_name = task.name | urlencode %}
                        <a href="https://flux-gfb.tesla.com/app/schedules/planner-maintenance-grid?status=NEW&status=IN_PRG&status=WT_PT&status=SCH_HD&status=RD_PICKUP&status=RDY_TO_ASSG&status=IN_PLAN&status=IN_BUILD&status=ASSGN&assetViewIds=2642&name={{ encoded_name }}" target="_blank">
                            Flux MOs
                        </a>
                    {% else %}
                        N/A
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
            {% endif %}

            <!-- REP Section -->
            {% if rep_tasks %}
            <tr class="section-header">
                <td colspan="9">
                    Tickets/MOs/Engineering Requests
                </td>
            </tr>
            {% for task in rep_tasks %}
            <tr class="task-row-rep">
                <td class="index-cell" style="background-color: #{{ '%02x%02x%02x' % ((task.id | int | default(1)) * 97 % 200 + 55, (task.id | int | default(1)) * 53 % 200 + 55, (task.id | int | default(1)) * 37 % 200 + 55) }}; color: #fff;">
                    {{ task.id }}
                </td>
                <td>
                    {{ task.name }}
                    {% set unassigned_instance_details_rep = [] %}
                    {% set incomplete_instances_list_rep = [] %}
                    {% for i in range(task.quantity | int | default(1)) %}
                        {% set current_instance_id = task.id ~ '_' ~ (i + 1) %}
                        {% if unassigned_tasks and current_instance_id in unassigned_tasks %}
                            {% set _ = unassigned_instance_details_rep.append({'num': i + 1, 'reason': unassigned_tasks[current_instance_id]}) %}
                        {% endif %}
                        {% if incomplete_tasks and current_instance_id in incomplete_tasks %}
                            {% set _ = incomplete_instances_list_rep.append(i + 1) %}
                        {% endif %}
                    {% endfor %}
                    {% if unassigned_instance_details_rep %}
                        {% set unassigned_numbers_rep = unassigned_instance_details_rep | map(attribute='num') | list %}
                        {% set unassigned_reasons_tooltip_lines_rep = [] %}
                        {% for detail in unassigned_instance_details_rep %}
                            {% set _ = unassigned_reasons_tooltip_lines_rep.append("Instance " ~ detail.num ~ ": " ~ detail.reason) %}
                        {% endfor %}
                        <br><span style="color: red; font-size: 0.9em;" title="{{ unassigned_reasons_tooltip_lines_rep | join('\n') }}">
                            Unassigned: {{ unassigned_numbers_rep | join(', ') }}
                        </span>
                    {% endif %}
                    {% if incomplete_instances_list_rep %}
                        <br><span style="color: orange; font-size: 0.9em;" title="Instances {{ incomplete_instances_list_rep | join(', ') }} were partially assigned due to shift end.">
                            Partially Assigned: {{ incomplete_instances_list_rep | join(', ') }}
                        </span>
                    {% endif %}
                </td>
                <td>
                    {% if task.lines is none or task.lines == 'nan' or task.lines == '' %}
                        N/A
                    {% else %}
                        {{ task.lines }}
                    {% endif %}
                </td>
                <td>{{ task.mitarbeiter_pro_aufgabe | default('1') }}</td>
                <td>
                    {% set assigned_techs_for_rep = [] %}
                    {% if assignments %}
                        {% for assignment in assignments if assignment.instance_id.startswith(task.id ~ '_') %}
                            {% if assignment.technician not in assigned_techs_for_rep %}
                                {% set _ = assigned_techs_for_rep.append(assignment.technician) %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}
                    {{ assigned_techs_for_rep | sort | join(', ') | default('None') }}
                </td>
                <td>{{ task.planned_worktime_min | default('0') }}</td>
                <td class="{% if task.priority == 'A' %}prio-a{% elif task.priority == 'B' %}prio-b{% elif task.priority == 'C' %}prio-c{% else %}prio-c{% endif %}">
                    {{ task.priority | default('C') }}
                </td>
                <td>{{ task.quantity | default('1') }}</td>
                <td>
                    {% if task.task_type.upper() == 'REP' and task.ticket_mo and task.ticket_mo != 'nan' %}
                        {% if task.ticket_url %}
                            <a href="{{ task.ticket_url }}" target="_blank">{{ task.ticket_mo }}</a>
                        {% else %}
                            {{ task.ticket_mo }}
                        {% endif %}
                    {% elif task.task_type.upper() == 'PM' %}
                        {% set encoded_name = task.name | urlencode %}
                        <a href="https://flux-gfb.tesla.com/app/schedules/planner-maintenance-grid?status=NEW&status=IN_PRG&status=WT_PT&status=SCH_HD&status=RD_PICKUP&status=RDY_TO_ASSG&status=IN_PLAN&status=IN_BUILD&status=ASSGN&assetViewIds=2642&name={{ encoded_name }}" target="_blank">
                            Flux MOs
                        </a>
                    {% else %}
                        N/A
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
            {% endif %}
        </tbody>
    </table>

    <!-- Gantt Chart -->
    <h2>Gantt Chart: {{ total_work_minutes | default(0) }} min of work</h2>
    {% if technicians | length == 0 %}
    <p>No technicians available to display in the Gantt chart.</p>
    {% else %}
    <div class="gantt-container"
         data-total-work-minutes="{{ total_work_minutes | default(0) }}"
         data-shift-start-time="{{ shift_start_time_str | default('06:00') }}">

        <div class="gantt-chart"> <!-- Will become a flex container for two panes -->

            <!-- New: Fixed Left Pane -->
            <div class="gantt-fixed-left-pane">
                <div class="clock-time-axis-spacer-wrapper axis-container">
                    <!-- JS will populate ONLY the spacer tick for the clock axis here -->
                </div>
                <div class="work-interval-axis-spacer-wrapper axis-container">
                    <!-- JS will populate ONLY the spacer tick for the work interval axis here -->
                </div>
                <div class="technician-labels-wrapper">
                    {% for technician in technicians %}
                        <div class="technician-label">{{ technician }}</div>
                    {% endfor %}
                </div>
            </div>

            <!-- New: Scrollable Right Pane -->
            <div class="gantt-scrollable-right-pane">
                <div class="clock-time-axis-ticks-wrapper axis-container">
                    <!-- JS will populate the actual time ticks (no spacer) for the clock axis here -->
                </div>
                <div class="work-interval-axis-ticks-wrapper axis-container">
                    <!-- JS will populate the actual time ticks (no spacer) for the work interval axis here -->
                </div>
                <div class="time-grids-wrapper">
                    {% for technician in technicians %}
                    {# Note: The technician-row div is removed, we directly create time-grids #}
                    <div class="time-grid">
                        {# Master task bars rendered by Jinja - JS will hide these and create new segmented bars #}
                        {% for assignment in assignments %}
                            {% if assignment.technician == technician %}
                                {% set task_id_num = assignment.instance_id.split('_')[0] if assignment.instance_id and '_' in assignment.instance_id else '0' %}
                                {% set color_r = ((task_id_num | int | default(1)) * 97 % 200 + 55) %}
                                {% set color_g = ((task_id_num | int | default(1)) * 53 % 200 + 55) %}
                                {% set color_b = ((task_id_num | int | default(1)) * 37 % 200 + 55) %}
                                <div class="task-bar"
                                     data-assignment-start="{{ assignment.start | default(0) }}"
                                     data-assignment-duration="{{ assignment.duration | default(0) }}"
                                     data-task-id="{{ task_id_num | default('0') }}"
                                     style="
                                        background-color: #{{ '%02x%02x%02x' % (color_r, color_g, color_b) }};
                                        {% if assignment.is_incomplete %}border: 2px solid red;{% endif %}
                                        display: none; /* Initially hide, JS will create visible segments */
                                     "
                                     title="{{ assignment.task_name | default('Unknown') }} (Work Time: {{ assignment.start | default(0) }}-{{ (assignment.start | default(0)) + (assignment.duration | default(0)) }} min{% if assignment.is_incomplete %} - Partially assigned, full ideal duration for group: {{ assignment.original_duration | default(0) }} min{% endif %}{% if assignment.resource_mismatch_info %} - {{ assignment.resource_mismatch_info }}{% endif %})">
                                     <span>{{ task_id_num | default('0') }}</span>
                                </div>
                            {% endif %}
                        {% endfor %}
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const ganttContainer = document.querySelector('.gantt-container');
        if (!ganttContainer) return;

        const totalWorkMinutes = parseInt(ganttContainer.dataset.totalWorkMinutes);
        const shiftStartTimeStr = ganttContainer.dataset.shiftStartTime;

        if (isNaN(totalWorkMinutes) || !shiftStartTimeStr) {
            console.error("Missing data for Gantt chart initialization.");
            return;
        }
        if (totalWorkMinutes === 0 && {{technicians | length}} > 0) {
             generateDynamicGantt(shiftStartTimeStr, 0);
        } else if (totalWorkMinutes > 0) {
            generateDynamicGantt(shiftStartTimeStr, totalWorkMinutes);
        } else if ({{ technicians | length }} === 0 && totalWorkMinutes === 0) {
            generateDynamicGantt(shiftStartTimeStr, 0);
        }
    });

    function formatTime(dateObj) {
        const hours = dateObj.getHours().toString().padStart(2, '0');
        const minutes = dateObj.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    function setupGanttScrollSync() {
        const rightPane = document.querySelector('.gantt-scrollable-right-pane');
        const leftPaneLabelsWrapper = document.querySelector('.technician-labels-wrapper');
        const clockTicksWrapper = document.querySelector('.clock-time-axis-ticks-wrapper');
        const workIntervalTicksWrapper = document.querySelector('.work-interval-axis-ticks-wrapper');

        if (rightPane && leftPaneLabelsWrapper && clockTicksWrapper && workIntervalTicksWrapper) {
            rightPane.addEventListener('scroll', function() {
                // Sync vertical scroll of technician labels in the left pane
                leftPaneLabelsWrapper.scrollTop = this.scrollTop;

                // Sync horizontal scroll of the header tick sections in the right pane
                // Check if elements are still in DOM and visible before setting scrollLeft
                if (clockTicksWrapper.offsetParent !== null) { // A simple check for visibility/DOM presence
                    clockTicksWrapper.scrollLeft = this.scrollLeft;
                }
                if (workIntervalTicksWrapper.offsetParent !== null) {
                    workIntervalTicksWrapper.scrollLeft = this.scrollLeft;
                }
            });
        } else {
            console.error("Gantt scroll sync elements not found. Check selectors:",
                {rightPane, leftPaneLabelsWrapper, clockTicksWrapper, workIntervalTicksWrapper}
            );
        }
    }


    function generateDynamicGantt(shiftStartTimeStr, totalWorkMinutes) {
        // MODIFIED: Select new wrapper elements
        const clockSpacerWrapper = document.querySelector('.clock-time-axis-spacer-wrapper');
        const workIntervalSpacerWrapper = document.querySelector('.work-interval-axis-spacer-wrapper');
        const clockTicksWrapper = document.querySelector('.clock-time-axis-ticks-wrapper');
        const workIntervalTicksWrapper = document.querySelector('.work-interval-axis-ticks-wrapper');

        // Select all time grids from the new wrapper
        const timeGrids = document.querySelectorAll('.time-grids-wrapper .time-grid');

        // Clear previous content from new wrappers
        if (clockSpacerWrapper) clockSpacerWrapper.innerHTML = ''; else console.error('.clock-time-axis-spacer-wrapper not found');
        if (workIntervalSpacerWrapper) workIntervalSpacerWrapper.innerHTML = ''; else console.error('.work-interval-axis-spacer-wrapper not found');
        if (clockTicksWrapper) clockTicksWrapper.innerHTML = ''; else console.error('.clock-time-axis-ticks-wrapper not found');
        if (workIntervalTicksWrapper) workIntervalTicksWrapper.innerHTML = ''; else console.error('.work-interval-axis-ticks-wrapper not found');


        const workIntervalDuration = 15;
        const timelineSlots = [];
        let workTimeProcessed = 0;
        const break1StartAfterWork = Math.floor(totalWorkMinutes * 0.25 / workIntervalDuration) * workIntervalDuration;
        const breakMainStartAfterWork = Math.floor(totalWorkMinutes * 0.50 / workIntervalDuration) * workIntervalDuration;
        const break2StartAfterWork = Math.floor(totalWorkMinutes * 0.75 / workIntervalDuration) * workIntervalDuration;
        const break1Duration = 15;
        const breakMainDuration = 60;
        const break2Duration = 15;

        const breakPointsConfig = [
            { triggerWorkTime: break1StartAfterWork, duration: break1Duration, type: 'break1', taken: false },
            { triggerWorkTime: breakMainStartAfterWork, duration: breakMainDuration, type: 'breakMain', taken: false },
            { triggerWorkTime: break2StartAfterWork, duration: break2Duration, type: 'break2', taken: false }
        ].sort((a, b) => a.triggerWorkTime - b.triggerWorkTime);

        if (totalWorkMinutes > 0) {
            while (workTimeProcessed < totalWorkMinutes) {
                let breakAddedInIteration = false;
                for (const bp of breakPointsConfig) {
                    if (!bp.taken && workTimeProcessed === bp.triggerWorkTime) {
                        for (let i = 0; i < bp.duration / workIntervalDuration; i++) {
                            timelineSlots.push({ type: bp.type, workTimeCovered: 0 });
                        }
                        bp.taken = true;
                        breakAddedInIteration = true;
                    }
                }
                if (workTimeProcessed < totalWorkMinutes) {
                    timelineSlots.push({ type: 'work', workTimeCovered: workIntervalDuration });
                    workTimeProcessed += workIntervalDuration;
                } else if (!breakAddedInIteration && workTimeProcessed >= totalWorkMinutes) {
                    break;
                }
            }
            for (const bp of breakPointsConfig) {
                if (!bp.taken && workTimeProcessed === bp.triggerWorkTime) {
                    for (let i = 0; i < bp.duration / workIntervalDuration; i++) {
                        timelineSlots.push({ type: bp.type, workTimeCovered: 0 });
                    }
                    bp.taken = true;
                }
            }
        } else {
             timelineSlots.push({ type: 'placeholder', workTimeCovered: 0 });
        }

        const numTotalTimelineSlots = timelineSlots.length;

        const createSpacerTick = () => {
            const spacer = document.createElement('div');
            spacer.classList.add('time-tick', 'spacer-tick');
            return spacer;
        };

        // Append spacer ticks to their new wrappers
        if (clockSpacerWrapper) clockSpacerWrapper.appendChild(createSpacerTick());
        if (workIntervalSpacerWrapper) workIntervalSpacerWrapper.appendChild(createSpacerTick());


        const [startHour, startMinute] = shiftStartTimeStr.split(':').map(Number);
        let currentClock = new Date(2000, 0, 1, startHour, startMinute);
        let cumulativeWorkMinutes = 0;

        // Populate Header Ticks
        timelineSlots.forEach((slot, index) => {
            const isLastRealSlot = (index === numTotalTimelineSlots - 1);
            const headerTickBorderStyle = isLastRealSlot ? "none" : "1px solid #e0e0e0";

            // Clock Time Axis Tick (for the scrollable part)
            const tickDivClock = document.createElement('div');
            tickDivClock.classList.add('time-tick');
            tickDivClock.style.borderRight = headerTickBorderStyle;
            let labelClock = formatTime(currentClock);
            if (slot.type !== 'work' && slot.type !== 'placeholder') {
                tickDivClock.classList.add('break-interval', `break-type-${slot.type}`);
            }
            if (slot.type === 'placeholder') {
                 labelClock = `${formatTime(currentClock)} (No Work Scheduled)`;
            }
            tickDivClock.textContent = labelClock;
            if (clockTicksWrapper) clockTicksWrapper.appendChild(tickDivClock);
            currentClock.setMinutes(currentClock.getMinutes() + workIntervalDuration);

            // Work Interval Axis Tick (for the scrollable part)
            const tickDivWork = document.createElement('div');
            tickDivWork.classList.add('time-tick');
            tickDivWork.style.borderRight = headerTickBorderStyle;
            if (slot.type === 'work') {
                tickDivWork.textContent = `${cumulativeWorkMinutes}-${cumulativeWorkMinutes + slot.workTimeCovered}`;
                cumulativeWorkMinutes += slot.workTimeCovered;
            } else if (slot.type === 'placeholder') {
                tickDivWork.textContent = "0-0";
            } else { // Break slot
                tickDivWork.textContent = 'Break';
                tickDivWork.classList.add('break-interval', `break-type-${slot.type}`);
            }
            if (workIntervalTicksWrapper) workIntervalTicksWrapper.appendChild(tickDivWork);
        });

        const ganttColumnMinWidth = '50px';

        // Set grid-template-columns for SPACER wrappers
        if (clockSpacerWrapper) clockSpacerWrapper.style.gridTemplateColumns = '1fr'; // Takes full width of its 200px parent
        if (workIntervalSpacerWrapper) workIntervalSpacerWrapper.style.gridTemplateColumns = '1fr';


        // Set grid-template-columns for TICKS wrappers and TIME GRIDS
        if (numTotalTimelineSlots > 0) {
            const ticksGridColsStyle = `repeat(${numTotalTimelineSlots}, minmax(${ganttColumnMinWidth}, 1fr))`;
            if (clockTicksWrapper) clockTicksWrapper.style.gridTemplateColumns = ticksGridColsStyle;
            if (workIntervalTicksWrapper) workIntervalTicksWrapper.style.gridTemplateColumns = ticksGridColsStyle;
            timeGrids.forEach(grid => {
                grid.style.gridTemplateColumns = ticksGridColsStyle;
            });
        } else {
            const fallbackTicksGridColsStyle = `minmax(${ganttColumnMinWidth}, 1fr)`;
            if (clockTicksWrapper) clockTicksWrapper.style.gridTemplateColumns = fallbackTicksGridColsStyle;
            if (workIntervalTicksWrapper) workIntervalTicksWrapper.style.gridTemplateColumns = fallbackTicksGridColsStyle;
            timeGrids.forEach(grid => {
                grid.style.gridTemplateColumns = fallbackTicksGridColsStyle;
            });
        }

        // --- Populate Break Column Fills AND Work Column Borders in Time Grids ---
        timeGrids.forEach(grid => {
            grid.querySelectorAll('.break-column-fill, .work-column-border-carrier').forEach(el => el.remove());
            timelineSlots.forEach((slot, index) => {
                const isLastSlot = (index === numTotalTimelineSlots - 1);
                const contentGridLineBorderStyle = isLastSlot ? "none" : "1px solid #e0e0e0";
                let columnElement = null;
                if (slot.type !== 'work' && slot.type !== 'placeholder') {
                    columnElement = document.createElement('div');
                    columnElement.classList.add('break-column-fill', `break-type-${slot.type}`);
                } else {
                    columnElement = document.createElement('div');
                    columnElement.classList.add('work-column-border-carrier');
                }
                if (columnElement) {
                    columnElement.style.gridColumn = `${index + 1} / span 1`;
                    columnElement.style.borderRight = contentGridLineBorderStyle;
                    grid.appendChild(columnElement);
                }
            });
        });

        function getTimelineSlotIndexForWorkStart(targetWorkMinutes) {
            if (totalWorkMinutes === 0 && timelineSlots.length > 0 && timelineSlots[0].type === 'placeholder') return 1;
            let cumulativeWorkTime = 0;
            for (let i = 0; i < timelineSlots.length; i++) {
                const slot = timelineSlots[i];
                if (slot.type === 'work') {
                    if (targetWorkMinutes >= cumulativeWorkTime && targetWorkMinutes < cumulativeWorkTime + slot.workTimeCovered) {
                        return i + 1;
                    }
                    cumulativeWorkTime += slot.workTimeCovered;
                }
                if (targetWorkMinutes === 0 && cumulativeWorkTime === 0 && slot.type === 'work') return i + 1;
            }
            if (targetWorkMinutes === totalWorkMinutes && totalWorkMinutes > 0) {
                let tempWorkTime = 0;
                for (let i = 0; i < timelineSlots.length; i++) {
                    if (timelineSlots[i].type === 'work') tempWorkTime += timelineSlots[i].workTimeCovered;
                    if (tempWorkTime === totalWorkMinutes) return i + 1;
                }
            }
            return numTotalTimelineSlots > 0 ? numTotalTimelineSlots : 1;
        }

        if (totalWorkMinutes > 0) {
            const allTechnicianGrids = timeGrids; // Use the new NodeList
            allTechnicianGrids.forEach(grid => {
                const masterTaskBars = Array.from(grid.querySelectorAll('.task-bar[style*="display: none"]'));
                grid.querySelectorAll('.task-bar:not([style*="display: none"])').forEach(bar => bar.remove());

                masterTaskBars.forEach(masterBar => {
                    const assignmentStartWorkMinutes = parseFloat(masterBar.dataset.assignmentStart);
                    const assignmentDurationWorkMinutes = parseFloat(masterBar.dataset.assignmentDuration);
                    const taskIdText = masterBar.dataset.taskId;

                    if (assignmentDurationWorkMinutes === 0) {
                        const timelineSlotStartCssIndex = getTimelineSlotIndexForWorkStart(assignmentStartWorkMinutes);
                        const segmentDiv = masterBar.cloneNode(true);
                        segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                        segmentDiv.style.gridColumn = `${timelineSlotStartCssIndex} / span 1`;
                        segmentDiv.style.display = 'flex';
                        segmentDiv.classList.add('zero-duration');
                        grid.appendChild(segmentDiv);
                        return;
                    }

                    let workMinutesProcessedForTask = 0;
                    let currentSegmentStartTimelineSlot_0_based = -1;
                    let timelineSlotCursor_0_based = 0;
                    let cumulativeWorkTimeForCursorSearch = 0;
                    let initialCursorFound = false;

                    for (let i = 0; i < timelineSlots.length; i++) {
                        if (timelineSlots[i].type === 'work') {
                            if (assignmentStartWorkMinutes >= cumulativeWorkTimeForCursorSearch &&
                                assignmentStartWorkMinutes < cumulativeWorkTimeForCursorSearch + timelineSlots[i].workTimeCovered) {
                                timelineSlotCursor_0_based = i;
                                initialCursorFound = true;
                                break;
                            }
                            cumulativeWorkTimeForCursorSearch += timelineSlots[i].workTimeCovered;
                        }
                        if (assignmentStartWorkMinutes === 0 && cumulativeWorkTimeForCursorSearch === 0 && timelineSlots[i].type === 'work') {
                            timelineSlotCursor_0_based = i;
                            initialCursorFound = true;
                            break;
                        }
                    }
                    if (!initialCursorFound && assignmentStartWorkMinutes === totalWorkMinutes) {
                        for (let i = timelineSlots.length - 1; i >= 0; i--) {
                            if (timelineSlots[i].type === 'work') {
                                timelineSlotCursor_0_based = i;
                                initialCursorFound = true;
                                break;
                            }
                        }
                    }
                    if (!initialCursorFound) {
                        console.warn(`Could not find starting slot for task: ${masterBar.title}, start: ${assignmentStartWorkMinutes}`);
                        return;
                    }

                    let previousSlotWasBreakForSegmentStart = false;

                    while (workMinutesProcessedForTask < assignmentDurationWorkMinutes && timelineSlotCursor_0_based < timelineSlots.length) {
                        const currentSlot = timelineSlots[timelineSlotCursor_0_based];

                        if (currentSlot.type === 'work') {
                            if (currentSegmentStartTimelineSlot_0_based === -1) {
                                currentSegmentStartTimelineSlot_0_based = timelineSlotCursor_0_based;
                                if (timelineSlotCursor_0_based > 0 &&
                                    timelineSlots[timelineSlotCursor_0_based - 1].type !== 'work' &&
                                    timelineSlots[timelineSlotCursor_0_based - 1].type !== 'placeholder') {
                                    if (workMinutesProcessedForTask > 0) {
                                        previousSlotWasBreakForSegmentStart = true;
                                    } else {
                                        previousSlotWasBreakForSegmentStart = false;
                                    }
                                } else {
                                    previousSlotWasBreakForSegmentStart = false;
                                }
                            }

                            const remainingWorkForTask = assignmentDurationWorkMinutes - workMinutesProcessedForTask;
                            workMinutesProcessedForTask += Math.min(currentSlot.workTimeCovered, remainingWorkForTask);

                            if (workMinutesProcessedForTask >= assignmentDurationWorkMinutes || timelineSlotCursor_0_based === timelineSlots.length - 1) {
                                const segmentDiv = masterBar.cloneNode(true);
                                segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                                const startCol = currentSegmentStartTimelineSlot_0_based + 1;
                                const endColExclusive = timelineSlotCursor_0_based + 1 + 1;
                                segmentDiv.style.gridColumn = `${startCol} / ${endColExclusive}`;
                                segmentDiv.style.display = 'flex';
                                if (previousSlotWasBreakForSegmentStart) {
                                    segmentDiv.classList.add('task-segment-starts-after-break');
                                }
                                if (timelineSlotCursor_0_based < timelineSlots.length - 1 &&
                                    timelineSlots[timelineSlotCursor_0_based + 1].type !== 'work' &&
                                    timelineSlots[timelineSlotCursor_0_based + 1].type !== 'placeholder') {
                                    if (workMinutesProcessedForTask < assignmentDurationWorkMinutes) {
                                        segmentDiv.classList.add('task-segment-ends-before-break');
                                    }
                                }
                                grid.appendChild(segmentDiv);
                                currentSegmentStartTimelineSlot_0_based = -1;
                                previousSlotWasBreakForSegmentStart = false;
                                break;
                            }
                        } else { // Break slot
                            if (currentSegmentStartTimelineSlot_0_based !== -1) {
                                const segmentDiv = masterBar.cloneNode(true);
                                segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                                const startCol = currentSegmentStartTimelineSlot_0_based + 1;
                                const endColExclusive = timelineSlotCursor_0_based + 1;
                                segmentDiv.style.gridColumn = `${startCol} / ${endColExclusive}`;
                                segmentDiv.style.display = 'flex';
                                if (previousSlotWasBreakForSegmentStart) {
                                    segmentDiv.classList.add('task-segment-starts-after-break');
                                }
                                segmentDiv.classList.add('task-segment-ends-before-break');
                                grid.appendChild(segmentDiv);
                                currentSegmentStartTimelineSlot_0_based = -1;
                                previousSlotWasBreakForSegmentStart = false;
                            }
                        }
                        timelineSlotCursor_0_based++;
                    }
                });
            });
        }
        // Call scroll sync after DOM is updated
        setupGanttScrollSync();
    }
    </script>
</body>
</html>