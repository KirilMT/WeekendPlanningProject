<!DOCTYPE html>
<html>
<head>
    <title>Technician Dashboard</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            overflow-x: hidden;
        }
        h1, h2 {
            text-align: center;
            color: #333;
            font-weight: 500;
        }
        .task-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-bottom: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        .task-table th {
            background-color: #e3f2fd;
            font-weight: 600;
            color: #333;
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .task-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            color: #333;
        }
        .task-table tr:last-child td {
            border-bottom: none;
        }
        .prio-a { background-color: #ff4d4d; color: #333; }
        .prio-b { background-color: #ffd700; color: #333; }
        .prio-c { background-color: #d2b48c; color: #333; }

        .gantt-container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            box-sizing: border-box;
            overflow: hidden; /* Important for sticky headers */
        }
        .gantt-chart {
            position: relative;
            overflow-x: auto;
            overflow-y: hidden; /* Keep this to allow content to scroll under sticky headers */
            display: flex;
            flex-direction: column;
            min-height: 0; /* For flexbox to behave in scrollable content */
        }
        .technician-row {
            display: grid;
            grid-template-columns: 200px auto; /* 'auto' for the .time-grid part */
            align-items: center; /* Vertically aligns label and time-grid content */
            min-height: 40px;
            position: relative;
            border-bottom: 1px solid #ccc; /* MODIFIED: Row carries the bottom border */
        }
        .technician-label {
            width: 200px;
            height: 40px; /* Explicit height */
            font-weight: 500;
            color: #333;
            padding: 0 10px;
            box-sizing: border-box;
            background-color: #f9f9f9; /* Ensure opaque background */
            text-align: left;
            word-wrap: break-word;
            position: sticky;
            left: 0;
            z-index: 10; /* MODIFIED: Increased z-index */
            display: flex;
            align-items: center;
            /* border-bottom removed, handled by .technician-row */
            border-right: 1px solid #ccc; /* MODIFIED: Added for consistent vertical line */
        }
        .time-grid {
            display: grid;
            /* JS will set grid-template-columns */
            grid-template-rows: 40px; /* Fixed height for task rows */
            grid-auto-rows: 0; /* Prevent implicit rows */
            position: relative; /* For z-indexing of break-column-fill */
            height: 40px; /* Explicit height */
            background: transparent;
            /* border-bottom removed, handled by .technician-row */
        }

        /* Common styles for axis containers */
        .axis-container {
            display: grid;
            /* JS will set grid-template-columns */
            position: sticky;
            background-color: #fff;
            z-index: 3; /* Standard z-index for headers */
        }
        .axis-container::after { /* Bottom border for axis */
            content: "";
            display: block;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            border-bottom: 1px solid #ddd;
        }

        .clock-time-axis { /* Top-most header */
            height: 25px;
            top: 0; /* Stick to the very top */
        }
        .work-interval-axis { /* Middle header */
            height: 30px;
            top: 25px; /* Stick below the clock-time-axis */
        }

        .time-tick { /* Common for all ticks in both axes headers */
            text-align: center;
            font-size: 9px;
            color: #666;
            padding: 5px 2px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            white-space: nowrap;
            /* border-right is now applied by JS for data ticks to handle the last one correctly */
        }
        .time-tick.spacer-tick { /* The first tick in headers (above tech labels) */
            width: 200px; /* Must match technician-label width */
            background-color: #f9f9f9; /* MODIFIED: Match technician label background */
            position: sticky;
            left: 0;
            z-index: 11; /* MODIFIED: Increased z-index, above technician-label */
            border-right: 1px solid #ccc; /* Match border with technician label */
        }

        /* Styles for break column fills in the content grid */
        .break-column-fill {
            grid-row: 1 / 2;
            height: 100%;
            z-index: 0; /* Behind task bars */
        }
        .break-column-fill.break-type-break1,
        .break-column-fill.break-type-break2 {
            background-color: #dcdcdc;
        }
        .break-column-fill.break-type-breakMain {
            background-color: #c0c0c0;
        }
        /* For work column border carriers in the content grid */
        .work-column-border-carrier {
            grid-row: 1 / 2;
            height: 100%;
            z-index: 0; /* Behind task bars */
        }


        .task-bar {
            grid-row: 1 / 2;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            box-sizing: border-box;
            overflow: visible; /* Allow pseudo-elements to show */
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
            margin: 8px 2px;
            position: relative;
            z-index: 1; /* Above break-column-fill and work-column-border-carrier */
        }
        .task-bar.zero-duration {
            width: 6px !important;
            min-width: 6px !important;
            height: 30px;
            margin-top: 5px;
            margin-bottom: 5px;
            border-radius: 1px;
            justify-self: center;
            padding: 0;
        }
        .task-bar.zero-duration span {
            display: none;
        }

        /* MODIFIED: Visual cues for split tasks - Thicker and darker */
        .task-segment-ends-before-break {
            margin-right: 4px;
        }
        .task-segment-ends-before-break::after {
            content: '';
            position: absolute;
            right: -5px;
            top: 0;
            bottom: 0;
            width: 5px;
            background:
                linear-gradient(135deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%),
                linear-gradient(45deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%);
            background-size: 10px 10px;
            background-repeat: repeat-y;
        }

        .task-segment-starts-after-break {
            margin-left: 4px;
        }
        .task-segment-starts-after-break::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 0;
            bottom: 0;
            width: 5px;
            background:
                linear-gradient(135deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%),
                linear-gradient(45deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%);
            background-size: 10px 10px;
            background-repeat: repeat-y;
            transform: scaleX(-1);
        }
        .task-bar span {
            position: relative;
            z-index: 1;
        }


        /* CSS for Break Ticks in headers */
        .time-tick.break-interval {
            background-color: #e7e7e7;
            font-style: italic;
            color: #555;
        }
        .time-tick.break-interval.break-type-break1,
        .time-tick.break-interval.break-type-break2 {
            background-color: #dcdcdc;
        }
        .time-tick.break-interval.break-type-breakMain {
            background-color: #c0c0c0;
        }
        /* --- START: CSS for Task Table (existing styles) --- */
        .task-table tr:not(.section-header):not(.task-row-rep):hover td:not(.prio-a):not(.prio-b):not(.prio-c) {
            background-color: #e9e9e9;
        }
        .task-table tr.section-header td {
            background-color: #d3d3d3;
            text-align: left;
            font-weight: bold;
            padding: 8px 16px;
        }
        .task-table tr.task-row-rep td.prio-a { background-color: #ff4d4d; color: #333; }
        .task-table tr.task-row-rep td.prio-b { background-color: #ffd700; color: #333; }
        .task-table tr.task-row-rep td.prio-c { background-color: #d2b48c; color: #333; }
        .task-table tr.task-row-rep:hover td:not(.prio-a):not(.prio-b):not(.prio-c) {
            background-color: #d1d1d1;
        }
        .task-table tr:hover td.prio-a { background-color: #ff4d4d; color: #333; }
        .task-table tr:hover td.prio-b { background-color: #ffd700; color: #333; }
        .task-table tr:hover td.prio-c { background-color: #d2b48c; color: #333; }
        /* --- END: CSS for Task Table --- */

    </style>
</head>
<body>
    <h1>Technician Dashboard</h1>

    <!-- Task Table (Structure remains as per your last provided version) -->
    <table class="task-table" border="1">
        <thead>
            <tr>
                <th>Index</th>
                <th>Tasks</th>
                <th>Lines</th>
                <th>Technicians</th>
                <th>Assigned Technicians (prio index)</th>
                <th>Time [min]</th>
                <th>Prio</th>
                <th>Qty</th>
                <th>Ticket/MO</th>
            </tr>
        </thead>
        <tbody>
            {% set pm_tasks = tasks | selectattr('task_type', 'equalto', 'PM') | list %}
            {% set rep_tasks = tasks | selectattr('task_type', 'equalto', 'REP') | list %}

            <!-- PM Section -->
            {% if pm_tasks %}
            <tr class="section-header">
                <td colspan="9">
                    PMs & PdMs
                </td>
            </tr>
            {% for task in pm_tasks %}
            <tr>
                <td class="index-cell" style="background-color: #{{ '%02x%02x%02x' % ((task.id | int | default(1)) * 97 % 200 + 55, (task.id | int | default(1)) * 53 % 200 + 55, (task.id | int | default(1)) * 37 % 200 + 55) }}; color: #fff;">
                    {{ task.id }}
                </td>
                <td>
                    {{ task.name }}
                    {% set unassigned_instance_details = [] %}
                    {% set incomplete_instances_list = [] %}
                    {% for i in range(task.quantity | int | default(1)) %}
                        {% set current_instance_id = task.id ~ '_' ~ (i + 1) %}
                        {% if unassigned_tasks and current_instance_id in unassigned_tasks %}
                            {% set _ = unassigned_instance_details.append({'num': i + 1, 'reason': unassigned_tasks[current_instance_id]}) %}
                        {% endif %}
                        {% if incomplete_tasks and current_instance_id in incomplete_tasks %}
                            {% set _ = incomplete_instances_list.append(i + 1) %}
                        {% endif %}
                    {% endfor %}
                    {% if unassigned_instance_details %}
                        {% set unassigned_numbers = unassigned_instance_details | map(attribute='num') | list %}
                        {% set unassigned_reasons_tooltip_lines = [] %}
                        {% for detail in unassigned_instance_details %}
                            {% set _ = unassigned_reasons_tooltip_lines.append("Instance " ~ detail.num ~ ": " ~ detail.reason) %}
                        {% endfor %}
                        <br><span style="color: red; font-size: 0.9em;" title="{{ unassigned_reasons_tooltip_lines | join('\n') }}">
                            Unassigned: {{ unassigned_numbers | join(', ') }}
                        </span>
                    {% endif %}
                    {% if incomplete_instances_list %}
                        <br><span style="color: orange; font-size: 0.9em;" title="Instances {{ incomplete_instances_list | join(', ') }} were partially assigned due to shift end.">
                            Partially Assigned: {{ incomplete_instances_list | join(', ') }}
                        </span>
                    {% endif %}
                </td>
                <td>
                    {% if task.lines is none or task.lines == 'nan' or task.lines == '' %}
                        N/A
                    {% else %}
                        {{ task.lines }}
                    {% endif %}
                </td>
                <td>{{ task.mitarbeiter_pro_aufgabe | default('1') }}</td>
                <td>
                    {% set tech_assignments_for_task = {} %}
                    {% if assignments %}
                        {% for assignment in assignments %}
                            {% if assignment.instance_id.startswith(task.id ~ '_') %}
                                {% if assignment.technician not in tech_assignments_for_task %}
                                    {% set _ = tech_assignments_for_task.update({assignment.technician: assignment.get('technician_task_priority', 'N/A')}) %}
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}
                    {% set assigned_tech_details = [] %}
                    {% for tech_name, tech_prio in tech_assignments_for_task.items() | sort %}
                        {% set _ = assigned_tech_details.append("%s (%s)" | format(tech_name, tech_prio)) %}
                    {% endfor %}
                    {{ assigned_tech_details | join(', ') if assigned_tech_details else 'None' }}
                </td>
                <td>{{ task.planned_worktime_min | default('0') }}</td>
                <td class="{% if task.priority == 'A' %}prio-a{% elif task.priority == 'B' %}prio-b{% elif task.priority == 'C' %}prio-c{% else %}prio-c{% endif %}">
                    {{ task.priority | default('C')}}
                </td>
                <td>{{ task.quantity | default('1') }}</td>
                <td>
                    {% if task.task_type.upper() == 'REP' and task.ticket_mo and task.ticket_mo != 'nan' %}
                        {% if task.ticket_url %}
                            <a href="{{ task.ticket_url }}" target="_blank">{{ task.ticket_mo }}</a>
                        {% else %}
                            {{ task.ticket_mo }}
                        {% endif %}
                    {% elif task.task_type.upper() == 'PM' %}
                        {% set encoded_name = task.name | urlencode %}
                        <a href="https://flux-gfb.tesla.com/app/schedules/planner-maintenance-grid?status=NEW&status=IN_PRG&status=WT_PT&status=SCH_HD&status=RD_PICKUP&status=RDY_TO_ASSG&status=IN_PLAN&status=IN_BUILD&status=ASSGN&assetViewIds=2642&name={{ encoded_name }}" target="_blank">
                            Flux MOs
                        </a>
                    {% else %}
                        N/A
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
            {% endif %}

            <!-- REP Section -->
            {% if rep_tasks %}
            <tr class="section-header">
                <td colspan="9">
                    Tickets/MOs/Engineering Requests
                </td>
            </tr>
            {% for task in rep_tasks %}
            <tr class="task-row-rep">
                <td class="index-cell" style="background-color: #{{ '%02x%02x%02x' % ((task.id | int | default(1)) * 97 % 200 + 55, (task.id | int | default(1)) * 53 % 200 + 55, (task.id | int | default(1)) * 37 % 200 + 55) }}; color: #fff;">
                    {{ task.id }}
                </td>
                <td>
                    {{ task.name }}
                    {% set unassigned_instance_details_rep = [] %}
                    {% set incomplete_instances_list_rep = [] %}
                    {% for i in range(task.quantity | int | default(1)) %}
                        {% set current_instance_id = task.id ~ '_' ~ (i + 1) %}
                        {% if unassigned_tasks and current_instance_id in unassigned_tasks %}
                            {% set _ = unassigned_instance_details_rep.append({'num': i + 1, 'reason': unassigned_tasks[current_instance_id]}) %}
                        {% endif %}
                        {% if incomplete_tasks and current_instance_id in incomplete_tasks %}
                            {% set _ = incomplete_instances_list_rep.append(i + 1) %}
                        {% endif %}
                    {% endfor %}
                    {% if unassigned_instance_details_rep %}
                        {% set unassigned_numbers_rep = unassigned_instance_details_rep | map(attribute='num') | list %}
                        {% set unassigned_reasons_tooltip_lines_rep = [] %}
                        {% for detail in unassigned_instance_details_rep %}
                            {% set _ = unassigned_reasons_tooltip_lines_rep.append("Instance " ~ detail.num ~ ": " ~ detail.reason) %}
                        {% endfor %}
                        <br><span style="color: red; font-size: 0.9em;" title="{{ unassigned_reasons_tooltip_lines_rep | join('\n') }}">
                            Unassigned: {{ unassigned_numbers_rep | join(', ') }}
                        </span>
                    {% endif %}
                    {% if incomplete_instances_list_rep %}
                        <br><span style="color: orange; font-size: 0.9em;" title="Instances {{ incomplete_instances_list_rep | join(', ') }} were partially assigned due to shift end.">
                            Partially Assigned: {{ incomplete_instances_list_rep | join(', ') }}
                        </span>
                    {% endif %}
                </td>
                <td>
                    {% if task.lines is none or task.lines == 'nan' or task.lines == '' %}
                        N/A
                    {% else %}
                        {{ task.lines }}
                    {% endif %}
                </td>
                <td>{{ task.mitarbeiter_pro_aufgabe | default('1') }}</td>
                <td>
                    {% set assigned_techs_for_rep = [] %}
                    {% if assignments %}
                        {% for assignment in assignments if assignment.instance_id.startswith(task.id ~ '_') %}
                            {% if assignment.technician not in assigned_techs_for_rep %}
                                {% set _ = assigned_techs_for_rep.append(assignment.technician) %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}
                    {{ assigned_techs_for_rep | sort | join(', ') | default('None') }}
                </td>
                <td>{{ task.planned_worktime_min | default('0') }}</td>
                <td class="{% if task.priority == 'A' %}prio-a{% elif task.priority == 'B' %}prio-b{% elif task.priority == 'C' %}prio-c{% else %}prio-c{% endif %}">
                    {{ task.priority | default('C') }}
                </td>
                <td>{{ task.quantity | default('1') }}</td>
                <td>
                    {% if task.task_type.upper() == 'REP' and task.ticket_mo and task.ticket_mo != 'nan' %}
                        {% if task.ticket_url %}
                            <a href="{{ task.ticket_url }}" target="_blank">{{ task.ticket_mo }}</a>
                        {% else %}
                            {{ task.ticket_mo }}
                        {% endif %}
                    {% elif task.task_type.upper() == 'PM' %}
                        {% set encoded_name = task.name | urlencode %}
                        <a href="https://flux-gfb.tesla.com/app/schedules/planner-maintenance-grid?status=NEW&status=IN_PRG&status=WT_PT&status=SCH_HD&status=RD_PICKUP&status=RDY_TO_ASSG&status=IN_PLAN&status=IN_BUILD&status=ASSGN&assetViewIds=2642&name={{ encoded_name }}" target="_blank">
                            Flux MOs
                        </a>
                    {% else %}
                        N/A
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
            {% endif %}
        </tbody>
    </table>

    <!-- Gantt Chart -->
    <h2>Gantt Chart: {{ total_work_minutes | default(0) }} min of work</h2>
    {% if technicians | length == 0 %}
    <p>No technicians available to display in the Gantt chart.</p>
    {% else %}
    <div class="gantt-container"
         data-total-work-minutes="{{ total_work_minutes | default(0) }}"
         data-shift-start-time="{{ shift_start_time_str | default('06:00') }}">
        <div class="gantt-chart">
            <!-- Top-most: Actual Clock Time Axis -->
            <div class="clock-time-axis axis-container">
                {# JS will populate ticks here #}
            </div>
            <!-- Middle: Work Interval Axis -->
            <div class="work-interval-axis axis-container">
                {# JS will populate ticks here #}
            </div>

            <!-- Technician Rows -->
            {% for technician in technicians %}
            <div class="technician-row">
                <div class="technician-label">{{ technician }}</div>
                <div class="time-grid"> {# JS will set its grid-template-columns #}
                    {# Master task bars rendered by Jinja - JS will hide these and create new segmented bars #}
                    {% for assignment in assignments %}
                        {% if assignment.technician == technician %}
                            {% set task_id_num = assignment.instance_id.split('_')[0] if assignment.instance_id and '_' in assignment.instance_id else '0' %}
                            {% set color_r = ((task_id_num | int | default(1)) * 97 % 200 + 55) %}
                            {% set color_g = ((task_id_num | int | default(1)) * 53 % 200 + 55) %}
                            {% set color_b = ((task_id_num | int | default(1)) * 37 % 200 + 55) %}
                            <div class="task-bar"
                                 data-assignment-start="{{ assignment.start | default(0) }}"
                                 data-assignment-duration="{{ assignment.duration | default(0) }}"
                                 data-task-id="{{ task_id_num | default('0') }}" {# Store task ID for text content #}
                                 style="
                                    background-color: #{{ '%02x%02x%02x' % (color_r, color_g, color_b) }};
                                    {% if assignment.is_incomplete %}border: 2px solid red;{% endif %}
                                    display: none; /* Initially hide, JS will create visible segments */
                                 "
                                 title="{{ assignment.task_name | default('Unknown') }} (Work Time: {{ assignment.start | default(0) }}-{{ (assignment.start | default(0)) + (assignment.duration | default(0)) }} min{% if assignment.is_incomplete %} - Partially assigned, full ideal duration for group: {{ assignment.original_duration | default(0) }} min{% endif %}{% if assignment.resource_mismatch_info %} - {{ assignment.resource_mismatch_info }}{% endif %})">
                                 <span>{{ task_id_num | default('0') }}</span> {# Text content in a span for zero-duration styling #}
                            </div>
                        {% endif %}
                    {% endfor %}
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
    {% endif %}

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const ganttContainer = document.querySelector('.gantt-container');
        if (!ganttContainer) return;

        const totalWorkMinutes = parseInt(ganttContainer.dataset.totalWorkMinutes);
        const shiftStartTimeStr = ganttContainer.dataset.shiftStartTime;

        if (isNaN(totalWorkMinutes) || !shiftStartTimeStr) {
            console.error("Missing data for Gantt chart initialization.");
            return;
        }
        if (totalWorkMinutes === 0 && {{technicians | length}} > 0) {
             generateDynamicGantt(shiftStartTimeStr, 0);
        } else if (totalWorkMinutes > 0) {
            generateDynamicGantt(shiftStartTimeStr, totalWorkMinutes);
        } else if ({{ technicians | length }} === 0 && totalWorkMinutes === 0) {
            generateDynamicGantt(shiftStartTimeStr, 0);
        }
    });

    function formatTime(dateObj) {
        const hours = dateObj.getHours().toString().padStart(2, '0');
        const minutes = dateObj.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    function generateDynamicGantt(shiftStartTimeStr, totalWorkMinutes) {
        const clockTimeAxisContainer = document.querySelector('.clock-time-axis');
        const workIntervalAxisContainer = document.querySelector('.work-interval-axis');
        const timeGrids = document.querySelectorAll('.time-grid');

        clockTimeAxisContainer.innerHTML = '';
        workIntervalAxisContainer.innerHTML = '';

        const workIntervalDuration = 15;

        const timelineSlots = [];
        let workTimeProcessed = 0;
        const break1StartAfterWork = Math.floor(totalWorkMinutes * 0.25 / workIntervalDuration) * workIntervalDuration;
        const breakMainStartAfterWork = Math.floor(totalWorkMinutes * 0.50 / workIntervalDuration) * workIntervalDuration;
        const break2StartAfterWork = Math.floor(totalWorkMinutes * 0.75 / workIntervalDuration) * workIntervalDuration;
        const break1Duration = 15;
        const breakMainDuration = 60;
        const break2Duration = 15;

        const breakPointsConfig = [
            { triggerWorkTime: break1StartAfterWork, duration: break1Duration, type: 'break1', taken: false },
            { triggerWorkTime: breakMainStartAfterWork, duration: breakMainDuration, type: 'breakMain', taken: false },
            { triggerWorkTime: break2StartAfterWork, duration: break2Duration, type: 'break2', taken: false }
        ].sort((a, b) => a.triggerWorkTime - b.triggerWorkTime);

        if (totalWorkMinutes > 0) {
            while (workTimeProcessed < totalWorkMinutes) {
                let breakAddedInIteration = false;
                for (const bp of breakPointsConfig) {
                    if (!bp.taken && workTimeProcessed === bp.triggerWorkTime) {
                        for (let i = 0; i < bp.duration / workIntervalDuration; i++) {
                            timelineSlots.push({ type: bp.type, workTimeCovered: 0 });
                        }
                        bp.taken = true;
                        breakAddedInIteration = true;
                    }
                }
                if (workTimeProcessed < totalWorkMinutes) {
                    timelineSlots.push({ type: 'work', workTimeCovered: workIntervalDuration });
                    workTimeProcessed += workIntervalDuration;
                } else if (!breakAddedInIteration && workTimeProcessed >= totalWorkMinutes) {
                    break;
                }
            }
            for (const bp of breakPointsConfig) {
                if (!bp.taken && workTimeProcessed === bp.triggerWorkTime) {
                    for (let i = 0; i < bp.duration / workIntervalDuration; i++) {
                        timelineSlots.push({ type: bp.type, workTimeCovered: 0 });
                    }
                    bp.taken = true;
                }
            }
        } else {
             timelineSlots.push({ type: 'placeholder', workTimeCovered: 0 });
        }

        const numTotalTimelineSlots = timelineSlots.length;

        const createSpacerTick = () => {
            const spacer = document.createElement('div');
            spacer.classList.add('time-tick', 'spacer-tick');
            return spacer;
        };
        clockTimeAxisContainer.appendChild(createSpacerTick());
        workIntervalAxisContainer.appendChild(createSpacerTick());

        const [startHour, startMinute] = shiftStartTimeStr.split(':').map(Number);
        let currentClock = new Date(2000, 0, 1, startHour, startMinute);
        let cumulativeWorkMinutes = 0;


        // Populate Header Ticks (Clock and Work Interval)
        timelineSlots.forEach((slot, index) => {
            const isLastRealSlot = (index === numTotalTimelineSlots - 1);
            const headerTickBorderStyle = isLastRealSlot ? "none" : "1px solid #e0e0e0"; // Header tick border color

            // Clock Time Axis Tick
            const tickDivClock = document.createElement('div');
            tickDivClock.classList.add('time-tick');
            tickDivClock.style.borderRight = headerTickBorderStyle;
            let labelClock = formatTime(currentClock);
            if (slot.type !== 'work' && slot.type !== 'placeholder') {
                tickDivClock.classList.add('break-interval', `break-type-${slot.type}`);
                labelClock += ` (${slot.type.replace('break', 'B')})`;
            }
            if (slot.type === 'placeholder') {
                 labelClock = `${formatTime(currentClock)} (No Work Scheduled)`;
            }
            tickDivClock.textContent = labelClock;
            clockTimeAxisContainer.appendChild(tickDivClock);
            currentClock.setMinutes(currentClock.getMinutes() + workIntervalDuration);

            // Work Interval Axis Tick
            const tickDivWork = document.createElement('div');
            tickDivWork.classList.add('time-tick');
            tickDivWork.style.borderRight = headerTickBorderStyle;
            if (slot.type === 'work') {
                tickDivWork.textContent = `${cumulativeWorkMinutes}-${cumulativeWorkMinutes + slot.workTimeCovered}`;
                cumulativeWorkMinutes += slot.workTimeCovered;
            } else if (slot.type === 'placeholder') {
                tickDivWork.textContent = "0-0";
            } else { // Break slot
                tickDivWork.textContent = slot.type.charAt(0).toUpperCase() + slot.type.slice(1).replace('break', 'Break ');
                tickDivWork.classList.add('break-interval', `break-type-${slot.type}`);
            }
            workIntervalAxisContainer.appendChild(tickDivWork);
        });


        if (numTotalTimelineSlots > 0) {
            const gridColsStyle = `200px repeat(${numTotalTimelineSlots}, minmax(60px, 1fr))`;
            clockTimeAxisContainer.style.gridTemplateColumns = gridColsStyle;
            workIntervalAxisContainer.style.gridTemplateColumns = gridColsStyle;
            timeGrids.forEach(grid => {
                grid.style.gridTemplateColumns = `repeat(${numTotalTimelineSlots}, minmax(60px, 1fr))`;
            });
        } else { // Should only happen if timelineSlots is unexpectedly empty
             const gridColsStyle = `200px minmax(60px, 1fr)`;
             clockTimeAxisContainer.style.gridTemplateColumns = gridColsStyle;
             workIntervalAxisContainer.style.gridTemplateColumns = gridColsStyle;
             timeGrids.forEach(grid => {
                grid.style.gridTemplateColumns = `minmax(60px, 1fr)`;
            });
        }

        // --- Populate Break Column Fills AND Work Column Borders in Time Grids ---
        timeGrids.forEach(grid => {
            grid.querySelectorAll('.break-column-fill, .work-column-border-carrier').forEach(el => el.remove());

            timelineSlots.forEach((slot, index) => {
                const isLastSlot = (index === numTotalTimelineSlots - 1);
                // Use a slightly lighter border for content grid lines for subtlety
                const contentGridLineBorderStyle = isLastSlot ? "none" : "1px solid #e0e0e0";

                let columnElement = null;

                if (slot.type !== 'work' && slot.type !== 'placeholder') { // Break slot
                    columnElement = document.createElement('div');
                    columnElement.classList.add('break-column-fill', `break-type-${slot.type}`);
                } else { // Work or Placeholder slot - needs a border carrier
                    columnElement = document.createElement('div');
                    columnElement.classList.add('work-column-border-carrier');
                }

                if (columnElement) {
                    columnElement.style.gridColumn = `${index + 1} / span 1`;
                    columnElement.style.borderRight = contentGridLineBorderStyle;
                    grid.appendChild(columnElement);
                }
            });
        });


        function getTimelineSlotIndexForWorkStart(targetWorkMinutes) {
            if (totalWorkMinutes === 0 && timelineSlots.length > 0 && timelineSlots[0].type === 'placeholder') return 1;
            let cumulativeWorkTime = 0;
            for (let i = 0; i < timelineSlots.length; i++) {
                const slot = timelineSlots[i];
                if (slot.type === 'work') {
                    if (targetWorkMinutes >= cumulativeWorkTime && targetWorkMinutes < cumulativeWorkTime + slot.workTimeCovered) {
                        return i + 1;
                    }
                    cumulativeWorkTime += slot.workTimeCovered;
                }
                if (targetWorkMinutes === 0 && cumulativeWorkTime === 0 && slot.type === 'work') return i + 1;
            }
            if (targetWorkMinutes === totalWorkMinutes && totalWorkMinutes > 0) {
                let tempWorkTime = 0;
                for (let i = 0; i < timelineSlots.length; i++) {
                    if (timelineSlots[i].type === 'work') tempWorkTime += timelineSlots[i].workTimeCovered;
                    if (tempWorkTime === totalWorkMinutes) return i + 1;
                }
            }
            return numTotalTimelineSlots > 0 ? numTotalTimelineSlots : 1;
        }

        if (totalWorkMinutes > 0) {
            const allTechnicianGrids = document.querySelectorAll('.time-grid');
            allTechnicianGrids.forEach(grid => {
                const masterTaskBars = Array.from(grid.querySelectorAll('.task-bar[style*="display: none"]'));
                grid.querySelectorAll('.task-bar:not([style*="display: none"])').forEach(bar => bar.remove());

                masterTaskBars.forEach(masterBar => {
                    const assignmentStartWorkMinutes = parseFloat(masterBar.dataset.assignmentStart);
                    const assignmentDurationWorkMinutes = parseFloat(masterBar.dataset.assignmentDuration);
                    const taskIdText = masterBar.dataset.taskId;

                    if (assignmentDurationWorkMinutes === 0) {
                        const timelineSlotStartCssIndex = getTimelineSlotIndexForWorkStart(assignmentStartWorkMinutes);
                        const segmentDiv = masterBar.cloneNode(true);
                        segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                        segmentDiv.style.gridColumn = `${timelineSlotStartCssIndex} / span 1`;
                        segmentDiv.style.display = 'flex';
                        segmentDiv.classList.add('zero-duration');
                        grid.appendChild(segmentDiv);
                        return;
                    }

                    let workMinutesProcessedForTask = 0;
                    let currentSegmentStartTimelineSlot_0_based = -1;
                    let timelineSlotCursor_0_based = 0;
                    let cumulativeWorkTimeForCursorSearch = 0;
                    let initialCursorFound = false;

                    for (let i = 0; i < timelineSlots.length; i++) {
                        if (timelineSlots[i].type === 'work') {
                            if (assignmentStartWorkMinutes >= cumulativeWorkTimeForCursorSearch &&
                                assignmentStartWorkMinutes < cumulativeWorkTimeForCursorSearch + timelineSlots[i].workTimeCovered) {
                                timelineSlotCursor_0_based = i;
                                initialCursorFound = true;
                                break;
                            }
                            cumulativeWorkTimeForCursorSearch += timelineSlots[i].workTimeCovered;
                        }
                        if (assignmentStartWorkMinutes === 0 && cumulativeWorkTimeForCursorSearch === 0 && timelineSlots[i].type === 'work') {
                            timelineSlotCursor_0_based = i;
                            initialCursorFound = true;
                            break;
                        }
                    }
                    if (!initialCursorFound && assignmentStartWorkMinutes === totalWorkMinutes) {
                        for (let i = timelineSlots.length - 1; i >= 0; i--) {
                            if (timelineSlots[i].type === 'work') {
                                timelineSlotCursor_0_based = i;
                                initialCursorFound = true;
                                break;
                            }
                        }
                    }
                    if (!initialCursorFound) {
                        console.warn(`Could not find starting slot for task: ${masterBar.title}, start: ${assignmentStartWorkMinutes}`);
                        return;
                    }

                    let previousSlotWasBreakForSegmentStart = false;

                    while (workMinutesProcessedForTask < assignmentDurationWorkMinutes && timelineSlotCursor_0_based < timelineSlots.length) {
                        const currentSlot = timelineSlots[timelineSlotCursor_0_based];

                        if (currentSlot.type === 'work') {
                            if (currentSegmentStartTimelineSlot_0_based === -1) {
                                currentSegmentStartTimelineSlot_0_based = timelineSlotCursor_0_based;
                                if (timelineSlotCursor_0_based > 0 && timelineSlots[timelineSlotCursor_0_based - 1].type !== 'work' && timelineSlots[timelineSlotCursor_0_based - 1].type !== 'placeholder') {
                                    previousSlotWasBreakForSegmentStart = true;
                                } else {
                                    previousSlotWasBreakForSegmentStart = false;
                                }
                            }
                            const remainingWorkForTask = assignmentDurationWorkMinutes - workMinutesProcessedForTask;
                            workMinutesProcessedForTask += Math.min(currentSlot.workTimeCovered, remainingWorkForTask);

                            if (workMinutesProcessedForTask >= assignmentDurationWorkMinutes || timelineSlotCursor_0_based === timelineSlots.length - 1) {
                                const segmentDiv = masterBar.cloneNode(true);
                                segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                                const startCol = currentSegmentStartTimelineSlot_0_based + 1;
                                const endColExclusive = timelineSlotCursor_0_based + 1 + 1;
                                segmentDiv.style.gridColumn = `${startCol} / ${endColExclusive}`;
                                segmentDiv.style.display = 'flex';
                                if (previousSlotWasBreakForSegmentStart) {
                                    segmentDiv.classList.add('task-segment-starts-after-break');
                                }
                                // Check if the *next* slot is a break to mark the end of this segment
                                if (timelineSlotCursor_0_based < timelineSlots.length - 1 && timelineSlots[timelineSlotCursor_0_based + 1].type !== 'work' && timelineSlots[timelineSlotCursor_0_based + 1].type !== 'placeholder') {
                                    segmentDiv.classList.add('task-segment-ends-before-break');
                                }
                                grid.appendChild(segmentDiv);
                                currentSegmentStartTimelineSlot_0_based = -1;
                                previousSlotWasBreakForSegmentStart = false;
                                break; // Task segment ends, or task fully completed
                            }
                        } else { // Break slot
                            if (currentSegmentStartTimelineSlot_0_based !== -1) { // If a segment was in progress
                                const segmentDiv = masterBar.cloneNode(true);
                                segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                                const startCol = currentSegmentStartTimelineSlot_0_based + 1;
                                const endColExclusive = timelineSlotCursor_0_based + 1; // Segment ends *at* the break slot (exclusive)
                                segmentDiv.style.gridColumn = `${startCol} / ${endColExclusive}`;
                                segmentDiv.style.display = 'flex';
                                if (previousSlotWasBreakForSegmentStart) {
                                    segmentDiv.classList.add('task-segment-starts-after-break');
                                }
                                segmentDiv.classList.add('task-segment-ends-before-break'); // Ends before this break
                                grid.appendChild(segmentDiv);
                                currentSegmentStartTimelineSlot_0_based = -1;
                                previousSlotWasBreakForSegmentStart = false;
                            }
                        }
                        timelineSlotCursor_0_based++;
                    }
                });
            });
        }
    }
    </script>
</body>
</html>