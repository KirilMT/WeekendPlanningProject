<!DOCTYPE html>
<html>
<head>
    <title>Technician Dashboard</title>
    <style>
        /* 1. Layout and Body */
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        /* 2. Headings */
        h1, h2, h4 {
            text-align: center;
            color: #333;
            font-weight: 500;
            margin-top: 0px;
            margin-bottom: 10px;
        }

        /* 3. Heading Container and Filter */
        #heading-container {
            display: flex;
            justify-content: center;
            align-items: baseline;
            gap: 15px;
            position: relative;
        }
        #filter {
            position: absolute;
            top: 0;
            left: 0;
        }
        #filter-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            font-size: 1rem;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        /* 4. Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: flex-start;
            align-items: flex-start;
        }
        .modal-content {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.18);
            padding: 0;
            min-width: 340px;
            max-width: 480px;
            width: 90%;
            position: absolute;
            transition: width 0.2s;
            overflow: hidden;
        }
        .modal-content.tasks-tab-active {
            min-width: 480px;
            max-width: 600px;
            width: 98vw;
        }
        .modal-header-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            background: #f7f7f7;
        }
        .modal-tab-btn {
            flex: 1;
            padding: 14px 0;
            font-size: 1.08em;
            font-weight: 500;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: background 0.15s, border-bottom 0.15s;
            color: #444;
        }
        .modal-tab-btn.active {
            background: #fff;
            border-bottom: 2.5px solid #007bff;
            color: #007bff;
            font-weight: 600;
        }
        .modal-tab-content {
            padding: 20px 22px 12px 22px;
            max-height: 340px;
            overflow-y: auto;
            min-height: 220px;
        }
        .modal-tab-content label {
            display: flex;
            align-items: center;
            padding: 5px 0;
            cursor: pointer;
            font-size: 1em;
            gap: 8px;
            user-select: none;
        }
        .modal-tab-content input[type="checkbox"] {
            margin-right: 8px;
            accent-color: #007bff;
        }
        .modal-tab-content .task-checkbox-label {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 420px;
            font-size: 1em;
        }
        .modal-content.tasks-tab-active .modal-tab-content .task-checkbox-label {
            max-width: 540px;
        }
        .modal-tab-content .task-checkbox-label.long {
            white-space: normal;
            word-break: break-word;
            overflow: visible;
            text-overflow: unset;
        }
        .modal-search-input {
            width: 100%;
            margin-bottom: 12px;
            padding: 8px 10px;
            border: 1px solid #d0d0d0;
            border-radius: 5px;
            font-size: 1em;
            background: #fafbfc;
            transition: border 0.15s;
        }
        .modal-search-input:focus {
            border: 1.5px solid #007bff;
            outline: none;
            background: #fff;
        }
        .modal-footer {
            display: flex;
            justify-content: space-between;
            padding: 12px 22px 18px 22px;
            background: #f7f7f7;
            border-top: 1px solid #e0e0e0;
        }
        .modal-footer button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.15s;
        }
        .modal-footer button#clearTechFilter {
            background: #aaa;
        }
        .modal-footer button:hover {
            filter: brightness(0.95);
        }
        @media (max-width: 600px) {
            .modal-content, .modal-content.tasks-tab-active {
                min-width: 0;
                max-width: 98vw;
                width: 98vw;
            }
            .modal-tab-content .task-checkbox-label,
            .modal-content.tasks-tab-active .modal-tab-content .task-checkbox-label {
                max-width: 90vw;
            }
        }

        /* 5. Task Table */
        .task-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-bottom: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        .task-table th {
            background-color: #e3f2fd;
            font-weight: 600;
            color: #333;
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .task-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            color: #333;
        }
        .task-table tr:last-child td {
            border-bottom: none;
        }
        .prio-a {
            background-color: #ff4d4d;
            color: #333;
        }
        .prio-b {
            background-color: #ffd700;
            color: #333;
        }
        .prio-c {
            background-color: #d2b48c;
            color: #333;
        }
        .task-table tr:not(.section-header):not(.task-row-rep):hover td:not(.prio-a):not(.prio-b):not(.prio-c) {
            background-color: #e9e9e9;
        }
        .task-table tr.section-header td {
            background-color: #d3d3d3;
            text-align: left;
            font-weight: bold;
            padding: 8px 16px;
        }
        .task-table tr.task-row-rep td {
            background-color: #e6e6e6;
        }
        .task-table tr.task-row-rep td.prio-a {
            background-color: #ff4d4d;
            color: #333;
        }
        .task-table tr.task-row-rep td.prio-b {
            background-color: #ffd700;
            color: #333;
        }
        .task-table tr.task-row-rep td.prio-c {
            background-color: #d2b48c;
            color: #333;
        }
        .task-table tr.task-row-rep:hover td:not(.prio-a):not(.prio-b):not(.prio-c) {
            background-color: #d1d1d1;
        }
        .task-table tr:hover td.prio-a {
            background-color: #ff4d4d;
            color: #333;
        }
        .task-table tr:hover td.prio-b {
            background-color: #ffd700;
            color: #333;
        }
        .task-table tr:hover td.prio-c {
            background-color: #d2b48c;
            color: #333;
        }

        /* 6. Gantt Chart Container */
        .gantt-container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            box-sizing: border-box;
            overflow: hidden;
        }
        .gantt-chart {
            position: relative;
            display: flex;
            min-height: 0;
        }
        .gantt-fixed-left-pane {
            width: 200px;
            flex-shrink: 0;
            position: relative;
            z-index: 20;
            background-color: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ccc;
        }
        .gantt-scrollable-right-pane {
            flex-grow: 1;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* 7. Gantt Axis and Ticks */
        .axis-container {
            display: grid;
            position: sticky;
            background-color: #fff;
        }
        .axis-container::after {
            content: "";
            display: block;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            border-bottom: 1px solid #ddd;
            z-index: 2;
        }
        .clock-time-axis-spacer-wrapper.axis-container::after,
        .work-interval-axis-spacer-wrapper.axis-container::after {
            border-bottom: none;
        }
        .clock-time-axis-spacer-wrapper {
            height: 25px;
            top: 0;
            z-index: 22;
        }
        .work-interval-axis-spacer-wrapper {
            height: 30px;
            top: 25px;
            z-index: 22;
        }
        .clock-time-axis-ticks-wrapper {
            height: 25px;
            top: 0;
            z-index: 15;
            width: auto;
            min-width: 100%;
        }
        .work-interval-axis-ticks-wrapper {
            height: 30px;
            top: 25px;
            z-index: 15;
            width: auto;
            min-width: 100%;
        }

        /* 8. Gantt Technician Labels */
        .technician-labels-wrapper {
            flex-grow: 1;
            overflow-y: hidden;
            position: relative;
            background-color: #f9f9f9;
        }
        .technician-label {
            width: 100%;
            height: 40px;
            font-weight: 500;
            color: #333;
            padding: 0 10px;
            box-sizing: border-box;
            background-color: #f9f9f9;
            text-align: left;
            word-wrap: break-word;
            display: flex;
            align-items: center;
            position: relative;
        }

        /* 9. Gantt Time Grids */
        .time-grids-wrapper {
            flex-grow: 1;
            position: relative;
            width: auto;
            min-width: 100%;
        }
        .time-grid {
            display: grid;
            grid-template-rows: 40px;
            grid-auto-rows: 0;
            position: relative;
            height: 40px;
            background: transparent;
            box-sizing: border-box;
            width: 100%;
        }
        .time-grid::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #ccc;
            z-index: 5 !important;
        }

        /* 10. Gantt Ticks and Breaks */
        .time-tick {
            text-align: center;
            font-size: 12px;
            color: #666;
            padding: 5px 2px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            white-space: nowrap;
        }
        .time-tick.spacer-tick {
            background-color: #f9f9f9;
        }
        .gantt-fixed-left-pane .time-tick.spacer-tick {
            border-right: none !important;
        }
        .break-column-fill,
        .work-column-border-carrier {
            grid-row: 1 / 2;
            height: 100%;
            position: relative;
            z-index: 0;
        }
        .break-column-fill.break-type-break1,
        .break-column-fill.break-type-break2 {
            background-color: #dcdcdc;
        }
        .break-column-fill.break-type-breakMain {
            background-color: #c0c0c0;
        }

        /* 11. Gantt Task Bars */
        .task-bar {
            grid-row: 1 / 2;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
            overflow: visible;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
            margin: 8px 2px;
            position: relative;
            z-index: 1;
        }
        .task-bar.zero-duration {
            width: 6px !important;
            min-width: 6px !important;
            height: 30px;
            margin-top: 5px;
            margin-bottom: 5px;
            border-radius: 1px;
            justify-self: center;
            padding: 0;
        }
        .task-bar.zero-duration span {
            display: none;
        }
        .task-segment-ends-before-break {
            margin-right: 4px;
        }
        .task-segment-ends-before-break::after {
            content: '';
            position: absolute;
            right: -5px;
            top: 0;
            bottom: 0;
            width: 5px;
            background: linear-gradient(135deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%),
            linear-gradient(45deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%);
            background-size: 10px 10px;
            background-repeat: repeat-y;
        }
        .task-segment-starts-after-break {
            margin-left: 4px;
        }
        .task-segment-starts-after-break::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 0;
            bottom: 0;
            width: 5px;
            background: linear-gradient(135deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%),
            linear-gradient(45deg, transparent 48%, #404040 48%, #404040 52%, transparent 52%);
            background-size: 10px 10px;
            background-repeat: repeat-y;
            transform: scaleX(-1);
        }
        .task-bar span {
            position: relative;
            z-index: 1;
        }

        /* 12. Gantt Break Ticks */
        .time-tick.break-interval {
            background-color: #e7e7e7;
            font-style: italic;
            color: #555;
        }
        .time-tick.break-interval.break-type-break1,
        .time-tick.break-interval.break-type-break2 {
            background-color: #dcdcdc;
        }
        .time-tick.break-interval.break-type-breakMain {
            background-color: #c0c0c0;
        }

        /* 13. Utility: Hover Highlights */
        .hover-highlight-technician {
            background-color: gold !important;
        }
        .hover-highlight-time-tick {
            background-color: gold !important;
        }
        .hover-highlight-time-grid-row {
            background-color: rgba(255, 220, 100, 0.3) !important;
        }
        .hover-highlight-grid-cell-column {
            background-color: rgba(255, 250, 205, 0.7) !important;
        }
    </style>
</head>
<body>
<div id="heading-container">
    <div id="filter">
        <button id="filter-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="filter-icon"
                 viewBox="0 0 16 16" aria-hidden="true">
                <path d="M1.5 1.5A.5.5 0 0 1 2 1h12a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.128.334L10 8.692V13.5a.5.5 0 0 1-.342.474l-3 1A.5.5 0 0 1 6 14.5V8.692L1.628 3.834A.5.5 0 0 1 1.5 3.5v-2zm1 .5v1.586l3.207 3.207a.5.5 0 0 1 .146.353V14l2-.666V7.308a.5.5 0 0 1 .146-.353L13.5 3.086V2h-11z"/>
            </svg>
            Filter
        </button>
    </div>
    <h1>Technician Dashboard</h1>
    <h4>(KW{{ week_date_day_shift.week }} - {{ week_date_day_shift.date }} - {{ week_date_day_shift.day }}
        - {{ week_date_day_shift.shift }})</h4>
</div>

<!-- Task Table -->
<table class="task-table" border="1">
    <thead>
    <tr>
        <th>Index</th>
        <th>Tasks</th>
        <th>Lines</th>
        <th>Technicians</th>
        <th>Assigned Technicians</th>
        <th>Time [min]</th>
        <th>Prio</th>
        <th>Qty</th>
        <th>Ticket/MO</th>
    </tr>
    </thead>
    <tbody>
    {% set pm_tasks = tasks | selectattr('task_type', 'equalto', 'PM') | list %}
    {% set rep_tasks = tasks | selectattr('task_type', 'equalto', 'REP') | list %}

    <!-- PM Section -->
    {% if pm_tasks %}
        <tr class="section-header">
            <td colspan="9">
                PMs & PdMs
            </td>
        </tr>
        {% for task in pm_tasks %}
            <tr>
                <td class="index-cell"
                    style="background-color: #{{ '%02x%02x%02x' % ((task.id | int | default(1)) * 97 % 200 + 55, (task.id | int | default(1)) * 53 % 200 + 55, (task.id | int | default(1)) * 37 % 200 + 55) }}; color: #fff;">
                    {{ task.id }}
                </td>
                <td>
                    {{ task.name }}
                    {% set unassigned_instance_details = [] %}
                    {% set incomplete_instances_list = [] %}
                    {% for i in range(task.quantity | int | default(1)) %}
                        {% set current_instance_id = task.id ~ '_' ~ (i + 1) %}
                        {% if unassigned_tasks and current_instance_id in unassigned_tasks %}
                            {% set _ = unassigned_instance_details.append({'num': i + 1, 'reason': unassigned_tasks[current_instance_id]}) %}
                        {% endif %}
                        {% if incomplete_tasks and current_instance_id in incomplete_tasks %}
                            {% set _ = incomplete_instances_list.append(i + 1) %}
                        {% endif %}
                    {% endfor %}
                    {% if unassigned_instance_details %}
                        {% set unassigned_numbers = unassigned_instance_details | map(attribute='num') | list %}
                        {% set unassigned_reasons_tooltip_lines = [] %}
                        {% for detail in unassigned_instance_details %}
                            {% set _ = unassigned_reasons_tooltip_lines.append("Instance " ~ detail.num ~ ": " ~ detail.reason) %}
                        {% endfor %}
                        <br><span style="color: red; font-size: 0.9em;"
                                  title="{{ unassigned_reasons_tooltip_lines | join('\n') }}">
                            Unassigned: {{ unassigned_numbers | join(', ') }}
                        </span>
                    {% endif %}
                    {% if incomplete_instances_list %}
                        <br><span style="color: orange; font-size: 0.9em;"
                                  title="Instances {{ incomplete_instances_list | join(', ') }} were partially assigned due to shift end.">
                            Partially Assigned: {{ incomplete_instances_list | join(', ') }}
                        </span>
                    {% endif %}
                </td>
                <td>
                    {% if task.lines is none or task.lines == 'nan' or task.lines == '' %}
                        N/A
                    {% else %}
                        {{ task.lines }}
                    {% endif %}
                </td>
                <td>{{ task.mitarbeiter_pro_aufgabe | default('1') }}</td>
                <td>
                    {# Group assignments by unique technician sets for the whole task #}
                    {% set group_counter = {} %}
                    {% if assignments %}
                        {% for i in range(task.quantity | int | default(1)) %}
                            {% set instance_id = task.id ~ '_' ~ (i + 1) %}
                            {% set group_assignments = assignments | selectattr('instance_id', 'equalto', instance_id) | list %}
                            {% if group_assignments %}
                                {% set group_names = group_assignments | map(attribute='technician') | list %}
                                {% set group_display = group_names | join(' & ') %}
                                {% set group_key = group_display %}
                                {% if group_counter[group_key] is defined %}
                                    {% set _ = group_counter.update({group_key: group_counter[group_key] + 1}) %}
                                {% else %}
                                    {% set _ = group_counter.update({group_key: 1}) %}
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}
                    {% set group_keys = group_counter.keys() | list %}
                    {% if group_keys %}
                        <div>
                        {% set highlight_colors = ['#e3f2fd', '#bbf7d0', '#ffe082', '#ffd6e0'] %}
                        {% for group_key in group_keys %}
                            {% set color = highlight_colors[loop.index0 % highlight_colors|length] if group_keys|length > 1 else '#e3f2fd' %}
                            <span style="display:inline-block; background:{{ color }}; color:#007bff; border-radius:4px; padding:2px 6px; margin-bottom:2px; margin-right:2px;">
                                [{{ group_key }}]
                            </span><br>
                        {% endfor %}
                        </div>
                    {% else %}
                        None
                    {% endif %}
                </td>
                <td>{{ task.planned_worktime_min | default('0') }}</td>
                <td class="{% if task.priority == 'A' %}prio-a{% elif task.priority == 'B' %}prio-b{% elif task.priority == 'C' %}prio-c{% else %}prio-c{% endif %}">
                    {{ task.priority | default('C') }}
                </td>
                <td>{{ task.quantity | default('1') }}</td>
                <td>
                    {% if task.task_type.upper() == 'REP' and task.ticket_mo and task.ticket_mo != 'nan' %}
                        {% if task.ticket_url %}
                            <a href="{{ task.ticket_url }}" target="_blank">{{ task.ticket_mo }}</a>
                        {% else %}
                            {{ task.ticket_mo }}
                        {% endif %}
                    {% elif task.task_type.upper() == 'PM' %}
                        {% set encoded_name = task.name | urlencode %}
                        <a href="https://flux-gfb.tesla.com/app/schedules/planner-maintenance-grid?status=NEW&status=IN_PRG&status=WT_PT&status=SCH_HD&status=RD_PICKUP&status=RDY_TO_ASSG&status=IN_PLAN&status=IN_BUILD&status=ASSGN&assetViewIds=2642&name={{ encoded_name }}"
                           target="_blank">
                            Flux MOs
                        </a>
                    {% else %}
                        N/A
                    {% endif %}
                </td>
            </tr>
        {% endfor %}
    {% endif %}

    <!-- REP Section -->
    {% if rep_tasks %}
        <tr class="section-header">
            <td colspan="9">
                Tickets/MOs/Engineering Requests
            </td>
        </tr>
        {% for task in rep_tasks %}
            <tr class="task-row-rep">
                <td class="index-cell"
                    style="background-color: #{{ '%02x%02x%02x' % ((task.id | int | default(1)) * 97 % 200 + 55, (task.id | int | default(1)) * 53 % 200 + 55, (task.id | int | default(1)) * 37 % 200 + 55) }}; color: #fff;">
                    {{ task.id }}
                </td>
                <td>
                    {{ task.name }}
                    {% set unassigned_instance_details_rep = [] %}
                    {% set incomplete_instances_list_rep = [] %}
                    {% for i in range(task.quantity | int | default(1)) %}
                        {% set current_instance_id = task.id ~ '_' ~ (i + 1) %}
                        {% if unassigned_tasks and current_instance_id in unassigned_tasks %}
                            {% set _ = unassigned_instance_details_rep.append({'num': i + 1, 'reason': unassigned_tasks[current_instance_id]}) %}
                        {% endif %}
                        {% if incomplete_tasks and current_instance_id in incomplete_tasks %}
                            {% set _ = incomplete_instances_list_rep.append(i + 1) %}
                        {% endif %}
                    {% endfor %}
                    {% if unassigned_instance_details_rep %}
                        {% set unassigned_numbers_rep = unassigned_instance_details_rep | map(attribute='num') | list %}
                        {% set unassigned_reasons_tooltip_lines_rep = [] %}
                        {% for detail in unassigned_instance_details_rep %}
                            {% set _ = unassigned_reasons_tooltip_lines_rep.append("Instance " ~ detail.num ~ ": " ~ detail.reason) %}
                        {% endfor %}
                        <br><span style="color: red; font-size: 0.9em;"
                                  title="{{ unassigned_reasons_tooltip_lines_rep | join('\n') }}">
                            Unassigned: {{ unassigned_numbers_rep | join(', ') }}
                        </span>
                    {% endif %}
                    {% if incomplete_instances_list_rep %}
                        <br><span style="color: orange; font-size: 0.9em;"
                                  title="Instances {{ incomplete_instances_list_rep | join(', ') }} were partially assigned due to shift end.">
                            Partially Assigned: {{ incomplete_instances_list_rep | join(', ') }}
                        </span>
                    {% endif %}
                </td>
                <td>
                    {% if task.lines is none or task.lines == 'nan' or task.lines == '' %}
                        N/A
                    {% else %}
                        {{ task.lines }}
                    {% endif %}
                </td>
                <td>{{ task.mitarbeiter_pro_aufgabe | default('1') }}</td>
                <td>
                    {# Same logic for REP section #}
                    {% set group_counter_rep = {} %}
                    {% if assignments %}
                        {% for i in range(task.quantity | int | default(1)) %}
                            {% set instance_id = task.id ~ '_' ~ (i + 1) %}
                            {% set group_assignments = assignments | selectattr('instance_id', 'equalto', instance_id) | list %}
                            {% if group_assignments %}
                                {% set group_names = group_assignments | map(attribute='technician') | list %}
                                {% set group_display = group_names | join(' & ') %}
                                {% set group_key = group_display %}
                                {% if group_counter_rep[group_key] is defined %}
                                    {% set _ = group_counter_rep.update({group_key: group_counter_rep[group_key] + 1}) %}
                                {% else %}
                                    {% set _ = group_counter_rep.update({group_key: 1}) %}
                                {% endif %}
                            {% endif %}
                        {% endfor %}
                    {% endif %}
                    {% set group_keys_rep = group_counter_rep.keys() | list %}
                    {% if group_keys_rep %}
                        <div>
                        {% set highlight_colors = ['#ffe082', '#bbf7d0', '#e3f2fd', '#ffd6e0'] %}
                        {% for group_key in group_keys_rep %}
                            {% set color = highlight_colors[loop.index0 % highlight_colors|length] if group_keys_rep|length > 1 else '#ffe082' %}
                            <span style="display:inline-block; background:{{ color }}; color:#b26a00; border-radius:4px; padding:2px 6px; margin-bottom:2px; margin-right:2px;">
                                [{{ group_key }}]
                            </span><br>
                        {% endfor %}
                        </div>
                    {% else %}
                        None
                    {% endif %}
                </td>
                <td>{{ task.planned_worktime_min | default('0') }}</td>
                <td class="{% if task.priority == 'A' %}prio-a{% elif task.priority == 'B' %}prio-b{% elif task.priority == 'C' %}prio-c{% else %}prio-c{% endif %}">
                    {{ task.priority | default('C') }}
                </td>
                <td>{{ task.quantity | default('1') }}</td>
                <td>
                    {% if task.task_type.upper() == 'REP' and task.ticket_mo and task.ticket_mo != 'nan' %}
                        {% if task.ticket_url %}
                            <a href="{{ task.ticket_url }}" target="_blank">{{ task.ticket_mo }}</a>
                        {% else %}
                            {{ task.ticket_mo }}
                        {% endif %}
                    {% elif task.task_type.upper() == 'PM' %}
                        {% set encoded_name = task.name | urlencode %}
                        <a href="https://flux-gfb.tesla.com/app/schedules/planner-maintenance-grid?status=NEW&status=IN_PRG&status=WT_PT&status=SCH_HD&status=RD_PICKUP&status=RDY_TO_ASSG&status=IN_PLAN&status=IN_BUILD&status=ASSGN&assetViewIds=2642&name={{ encoded_name }}"
                           target="_blank">
                            Flux MOs
                        </a>
                    {% else %}
                        N/A
                    {% endif %}
                </td>
            </tr>
        {% endfor %}
    {% endif %}
    </tbody>
</table>

<!-- Technician & Task Filter Modal -->
<div id="techFilterModal" class="modal" style="display:none;">
    <div class="modal-content" id="techFilterModalContent">
        <div class="modal-header-tabs">
            <button class="modal-tab-btn active" id="tabTechBtn" type="button">Technicians</button>
            <button class="modal-tab-btn" id="tabTaskBtn" type="button">Tasks</button>
        </div>
        <div class="modal-tab-content" id="tabTechContent">
            <input type="text" id="techFilterSearch" class="modal-search-input" placeholder="Search technicians...">
            <div class="technician-checkboxes" id="techFilterCheckboxes"></div>
        </div>
        <div class="modal-tab-content" id="tabTaskContent" style="display:none;">
            <input type="text" id="taskFilterSearch" class="modal-search-input" placeholder="Search tasks...">
            <div class="task-checkboxes" id="taskFilterCheckboxes"></div>
        </div>
        <div class="modal-footer">
            <button id="applyTechFilter">Apply</button>
            <button id="clearTechFilter">Clear</button>
        </div>
    </div>
</div>

<!-- Gantt Chart -->
<h2>Gantt Chart: {{ total_work_minutes | default(0) }} min of work</h2>
{% if technicians | length == 0 %}
    <p>No technicians available to display in the Gantt chart.</p>
{% else %}
    <div class="gantt-container"
         data-total-work-minutes="{{ total_work_minutes | default(0) }}"
         data-shift-start-time="{{ shift_start_time_str | default('06:00') }}"
         data-day="{{ week_date_day_shift.day|lower }}"
         data-shift-total-minutes="{{ shift_total_minutes | default(720) }}"
         data-shift-pm-start="{{ shift_pm_start_min | default(0) }}"
         data-shift-pm-end="{{ shift_pm_end_min | default(0) }}">

        <div class="gantt-chart">

            <!-- Fixed Left Pane -->
            <div class="gantt-fixed-left-pane">
                <div class="clock-time-axis-spacer-wrapper axis-container">
                    <!-- JS will populate ONLY the spacer tick for the clock axis here -->
                </div>
                <div class="work-interval-axis-spacer-wrapper axis-container">
                    <!-- JS will populate ONLY the spacer tick for the work interval axis here -->
                </div>
                <div class="technician-labels-wrapper">
                    {% for technician in technicians %}
                        <div class="technician-label">{{ technician }}</div>
                    {% endfor %}
                </div>
            </div>

            <!-- Scrollable Right Pane -->
            <div class=" gantt-scrollable-right-pane">
                <div class="clock-time-axis-ticks-wrapper axis-container">
                    <!-- JS will populate the actual time ticks (no spacer) for the clock axis here -->
                </div>
                <div class="work-interval-axis-ticks-wrapper axis-container">
                    <!-- JS will populate the actual time ticks (no spacer) for the work interval axis here -->
                </div>
                <div class="time-grids-wrapper">
                    {% for technician in technicians %}
                        <div class="time-grid">
                            {% for assignment in assignments %}
                                {% if assignment.technician == technician %}
                                    {% set task_id_num = assignment.instance_id.split('_')[0] if assignment.instance_id and '_' in assignment.instance_id else '0' %}
                                    {% set color_r = ((task_id_num | int | default(1)) * 97 % 200 + 55) %}
                                    {% set color_g = ((task_id_num | int | default(1)) * 53 % 200 + 55) %}
                                    {% set color_b = ((task_id_num | int | default(1)) * 37 % 200 + 55) %}
                                    <div class="task-bar"
                                         data-assignment-start="{{ assignment.start | default(0) }}"
                                         data-assignment-duration="{{ assignment.duration | default(0) }}"
                                         data-task-id="{{ task_id_num | default('0') }}"
                                         style="
                                                 background-color: #{{ '%02x%02x%02x' % (color_r, color_g, color_b) }};
                                                 {% if assignment.is_incomplete %}border: 2px solid red;{% endif %}
                                                 display: none;
                                                 "
                                         title="{{ assignment.task_name | default('Unknown') }} (Work Time: {{ assignment.start | default(0) }}-{{ (assignment.start | default(0)) + (assignment.duration | default(0)) }} min{% if assignment.is_incomplete %} - Partially assigned, full ideal duration for group: {{ assignment.original_duration | default(0) }} min{% endif %}{% if assignment.resource_mismatch_info %} - {{ assignment.resource_mismatch_info }}{% endif %})">
                                        <span>{{ task_id_num | default('0') }}</span>
                                    </div>
                                {% endif %}
                            {% endfor %}
                        </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
{% endif %}

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const ganttContainer = document.querySelector('.gantt-container');
        if (!ganttContainer) return;

        const totalWorkMinutes = parseInt(ganttContainer.dataset.totalWorkMinutes);
        const shiftStartTimeStr = ganttContainer.dataset.shiftStartTime;

        if (isNaN(totalWorkMinutes) || !shiftStartTimeStr) {
            console.error("Missing data for Gantt chart initialization.");
            return;
        }
        if (totalWorkMinutes === 0 && {{technicians | length}} > 0) {
            generateDynamicGantt(shiftStartTimeStr, 0);
        } else if (totalWorkMinutes > 0) {
            generateDynamicGantt(shiftStartTimeStr, totalWorkMinutes);
        } else if ({{ technicians | length }} === 0 && totalWorkMinutes === 0) {
            generateDynamicGantt(shiftStartTimeStr, 0);
        }
    });

    function formatTime(dateObj) {
        const hours = dateObj.getHours().toString().padStart(2, '0');
        const minutes = dateObj.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    function setupGanttScrollSync() {
        const rightPane = document.querySelector('.gantt-scrollable-right-pane');
        const leftPaneLabelsWrapper = document.querySelector('.technician-labels-wrapper');
        const clockTicksWrapper = document.querySelector('.clock-time-axis-ticks-wrapper');
        const workIntervalTicksWrapper = document.querySelector('.work-interval-axis-ticks-wrapper');

        if (rightPane && leftPaneLabelsWrapper && clockTicksWrapper && workIntervalTicksWrapper) {
            rightPane.addEventListener('scroll', function () {
                leftPaneLabelsWrapper.scrollTop = this.scrollTop;
                if (clockTicksWrapper.offsetParent !== null) {
                    clockTicksWrapper.scrollLeft = this.scrollLeft;
                }
                if (workIntervalTicksWrapper.offsetParent !== null) {
                    workIntervalTicksWrapper.scrollLeft = this.scrollLeft;
                }
            });
        } else {
            console.error("Gantt scroll sync elements not found. Check selectors:",
                {rightPane, leftPaneLabelsWrapper, clockTicksWrapper, workIntervalTicksWrapper}
            );
        }
    }

    function handleGanttCellHover(event) {
        const cell = event.target;
        const columnIndex = parseInt(cell.dataset.columnIndex);
        const parentGrid = cell.closest('.time-grid');

        if (!parentGrid || columnIndex === undefined || isNaN(columnIndex)) return;

        const allGridsNodeList = document.querySelectorAll('.time-grids-wrapper .time-grid');
        const allGridsArray = Array.from(allGridsNodeList);
        const technicianIndex = allGridsArray.indexOf(parentGrid);
        const technicianLabels = document.querySelectorAll('.technician-labels-wrapper .technician-label');

        if (technicianLabels[technicianIndex]) {
            technicianLabels[technicianIndex].classList.add('hover-highlight-technician');
        }

        const clockTicks = document.querySelectorAll('.clock-time-axis-ticks-wrapper .time-tick');
        const workIntervalTicks = document.querySelectorAll('.work-interval-axis-ticks-wrapper .time-tick');

        if (clockTicks[columnIndex]) {
            clockTicks[columnIndex].classList.add('hover-highlight-time-tick');
        }
        if (workIntervalTicks[columnIndex]) {
            workIntervalTicks[columnIndex].classList.add('hover-highlight-time-tick');
        }

        parentGrid.classList.add('hover-highlight-time-grid-row');

        allGridsNodeList.forEach(grid => {
            const cellInColumn = grid.querySelector(`[data-column-index="${columnIndex}"]`);
            if (cellInColumn) {
                cellInColumn.classList.add('hover-highlight-grid-cell-column');
            }
        });
    }

    function handleGanttCellMouseOut(event) {
        const cell = event.target;
        const columnIndex = parseInt(cell.dataset.columnIndex);
        const parentGrid = cell.closest('.time-grid');

        if (!parentGrid || columnIndex === undefined || isNaN(columnIndex)) return;

        const allGridsNodeList = document.querySelectorAll('.time-grids-wrapper .time-grid');
        const allGridsArray = Array.from(allGridsNodeList);
        const technicianIndex = allGridsArray.indexOf(parentGrid);
        const technicianLabels = document.querySelectorAll('.technician-labels-wrapper .technician-label');

        if (technicianLabels[technicianIndex]) {
            technicianLabels[technicianIndex].classList.remove('hover-highlight-technician');
        }

        const clockTicks = document.querySelectorAll('.clock-time-axis-ticks-wrapper .time-tick');
        const workIntervalTicks = document.querySelectorAll('.work-interval-axis-ticks-wrapper .time-tick');

        if (clockTicks[columnIndex]) {
            clockTicks[columnIndex].classList.remove('hover-highlight-time-tick');
        }
        if (workIntervalTicks[columnIndex]) {
            workIntervalTicks[columnIndex].classList.remove('hover-highlight-time-tick');
        }

        parentGrid.classList.remove('hover-highlight-time-grid-row');

        allGridsNodeList.forEach(grid => {
            const cellInColumn = grid.querySelector(`[data-column-index="${columnIndex}"]`);
            if (cellInColumn) {
                cellInColumn.classList.remove('hover-highlight-grid-cell-column');
            }
        });
    }

    function getBreaksForVisibleSection(day, totalWorkMinutes, shiftTotalMinutes, pmStartMin, pmEndMin) {
        const break1Duration = 15;
        const breakMainDuration = 60;
        const break2Duration = 15;

        // Main break: center of shift, but does NOT occupy time
        const mainBreakStart = (shiftTotalMinutes / 2) - (breakMainDuration / 2);
        // Work resumes at mainBreakStart (not after +breakMainDuration)
        // First 15min break: center of first half (from 0 to main break start)
        const break1Start = (mainBreakStart / 2) - (break1Duration / 2);

        // Second 15min break: center between end of main break (mainBreakStart) and end of shift (660)
        let break2Start;
        if (shiftTotalMinutes === 720) {
            // Center between 330 and 660
            break2Start = 330 + ((660 - 330) / 2) - (break2Duration / 2); // 487.5
        } else {
            // fallback for other shift lengths
            const intervalStart = mainBreakStart;
            const intervalEnd = shiftTotalMinutes - (shiftTotalMinutes - pmEndMin); // fallback to shift end
            break2Start = intervalStart + ((intervalEnd - intervalStart) / 2) - (break2Duration / 2);
        }

        const breaks = [
            { start: break1Start, duration: break1Duration, type: 'break1' },
            { start: mainBreakStart, duration: breakMainDuration, type: 'breakMain' },
            { start: break2Start, duration: break2Duration, type: 'break2' }
        ];

        if (day === 'saturday') {
            return breaks.map(b => ({
                start: b.start,
                duration: b.duration,
                type: b.type
            }));
        }

        // For Friday and Sunday, only part of the shift is PM section
        const visibleBreaks = [];
        for (const b of breaks) {
            const breakStart = b.start;
            const breakEnd = b.start + b.duration;
            const overlapStart = Math.max(breakStart, pmStartMin);
            const overlapEnd = Math.min(breakEnd, pmEndMin);
            if (overlapStart < overlapEnd) {
                visibleBreaks.push({
                    start: overlapStart,
                    duration: overlapEnd - overlapStart,
                    type: b.type,
                    offset: overlapStart - pmStartMin
                });
            }
        }
        // Map breaks to the visible section (0 to totalWorkMinutes)
        return visibleBreaks.map(b => ({
            start: b.offset,
            duration: b.duration,
            type: b.type
        }));
    }

    function generateDynamicGantt(shiftStartTimeStr, totalWorkMinutes) {
        const clockSpacerWrapper = document.querySelector('.clock-time-axis-spacer-wrapper');
        const workIntervalSpacerWrapper = document.querySelector('.work-interval-axis-spacer-wrapper');
        const clockTicksWrapper = document.querySelector('.clock-time-axis-ticks-wrapper');
        const workIntervalTicksWrapper = document.querySelector('.work-interval-axis-ticks-wrapper');
        const timeGrids = document.querySelectorAll('.time-grids-wrapper .time-grid');

        if (clockSpacerWrapper) clockSpacerWrapper.innerHTML = ''; else console.error('.clock-time-axis-spacer-wrapper not found');
        if (workIntervalSpacerWrapper) workIntervalSpacerWrapper.innerHTML = ''; else console.error('.work-interval-axis-spacer-wrapper not found');
        if (clockTicksWrapper) clockTicksWrapper.innerHTML = ''; else console.error('.clock-time-axis-ticks-wrapper not found');
        if (workIntervalTicksWrapper) workIntervalTicksWrapper.innerHTML = ''; else console.error('.work-interval-axis-ticks-wrapper not found');

        // --- Get day and shift info for break calculation ---
        const ganttContainer = document.querySelector('.gantt-container');
        let day = 'saturday';
        let shiftTotalMinutes = 720; // default 12h
        let pmStartMin = 0;
        let pmEndMin = totalWorkMinutes;
        if (ganttContainer) {
            day = ganttContainer.getAttribute('data-day') || 'saturday';
            shiftTotalMinutes = parseInt(ganttContainer.getAttribute('data-shift-total-minutes')) || 720;
            pmStartMin = parseInt(ganttContainer.getAttribute('data-shift-pm-start')) || 0;
            pmEndMin = parseInt(ganttContainer.getAttribute('data-shift-pm-end')) || totalWorkMinutes;
        }

        // --- Calculate breaks for the visible section ---
        const breaks = getBreaksForVisibleSection(day, totalWorkMinutes, shiftTotalMinutes, pmStartMin, pmEndMin);

        // --- Build timelineSlots with breaks in the correct positions ---
        const workIntervalDuration = 15;
        const timelineSlots = [];
        let workTimeProcessed = 0;
        let breakCursor = 0;

        while (workTimeProcessed < totalWorkMinutes) {
            // Insert break if it starts at this point
            if (
                breakCursor < breaks.length &&
                Math.abs(workTimeProcessed - Math.round(breaks[breakCursor].start / workIntervalDuration) * workIntervalDuration) < 1e-6
            ) {
                const breakSlots = Math.round(breaks[breakCursor].duration / workIntervalDuration);
                for (let i = 0; i < breakSlots; i++) {
                    timelineSlots.push({ type: breaks[breakCursor].type, workTimeCovered: 0 });
                }
                breakCursor++;
                continue;
            }
            // Add work slot
            timelineSlots.push({ type: 'work', workTimeCovered: workIntervalDuration });
            workTimeProcessed += workIntervalDuration;
        }

        const numTotalTimelineSlots = timelineSlots.length;

        const createSpacerTick = () => {
            const spacer = document.createElement('div');
            spacer.classList.add('time-tick', 'spacer-tick');
            return spacer;
        };

        if (clockSpacerWrapper) clockSpacerWrapper.appendChild(createSpacerTick());
        if (workIntervalSpacerWrapper) workIntervalSpacerWrapper.appendChild(createSpacerTick());

        // --- Improved: Calculate the correct clock start time for the Gantt header ---
        let startHour = 6, startMinute = 0;
        let customClock = null;
        if (day === 'friday') {
            // Weekend tasks start at 22:00 on Friday
            startHour = 22; startMinute = 0;
            customClock = new Date(2000, 0, 1, startHour, startMinute);
        } else if (day === 'sunday') {
            // Weekend tasks start at 06:00 on Sunday
            startHour = 6; startMinute = 0;
            customClock = new Date(2000, 0, 1, startHour, startMinute);
        } else {
            // Saturday or default: use shiftStartTimeStr
            [startHour, startMinute] = shiftStartTimeStr.split(':').map(Number);
            customClock = new Date(2000, 0, 1, startHour, startMinute);
        }

        // For Friday, if the Gantt covers 22:00 to 06:00 (overnight), handle day wrap
        function addMinutesWithWrap(dateObj, minutes) {
            let newDate = new Date(dateObj.getTime());
            newDate.setMinutes(newDate.getMinutes() + minutes);
            // If hour >= 24, wrap to next day (for display, not real date)
            if (newDate.getHours() >= 24) {
                newDate.setHours(newDate.getHours() - 24);
            }
            return newDate;
        }

        // --- Use customClock for the time header ---
        let currentClock = new Date(customClock.getTime());
        let cumulativeWorkMinutes = 0;

        timelineSlots.forEach((slot, index) => {
            const isLastRealSlot = (index === numTotalTimelineSlots - 1);
            const headerTickBorderStyle = isLastRealSlot ? "none" : "1px solid #e0e0e0";

            const tickDivClock = document.createElement('div');
            tickDivClock.classList.add('time-tick');
            tickDivClock.style.borderRight = headerTickBorderStyle;
            let labelClock = formatTime(currentClock);
            if (slot.type !== 'work' && slot.type !== 'placeholder') {
                tickDivClock.classList.add('break-interval', `break-type-${slot.type}`);
            }
            if (slot.type === 'placeholder') {
                labelClock = `${formatTime(currentClock)} (No Work Scheduled)`;
            }
            tickDivClock.textContent = labelClock;
            if (clockTicksWrapper) clockTicksWrapper.appendChild(tickDivClock);

            // --- Advance time, with wrap for Friday overnight ---
            if (day === 'friday') {
                currentClock = addMinutesWithWrap(currentClock, 15);
            } else {
                currentClock.setMinutes(currentClock.getMinutes() + 15);
            }

            const tickDivWork = document.createElement('div');
            tickDivWork.classList.add('time-tick');
            tickDivWork.style.borderRight = headerTickBorderStyle;
            if (slot.type === 'work') {
                tickDivWork.textContent = `${cumulativeWorkMinutes}-${cumulativeWorkMinutes + slot.workTimeCovered}`;
                cumulativeWorkMinutes += slot.workTimeCovered;
            } else if (slot.type === 'placeholder') {
                tickDivWork.textContent = "0-0";
            } else {
                tickDivWork.textContent = 'Break';
                tickDivWork.classList.add('break-interval', `break-type-${slot.type}`);
            }
            if (workIntervalTicksWrapper) workIntervalTicksWrapper.appendChild(tickDivWork);
        });

        const ganttColumnMinWidth = '50px';
        const ganttColumnMinWidthPx = parseInt(ganttColumnMinWidth);
        const totalWidth = numTotalTimelineSlots * ganttColumnMinWidthPx;

        // Set widths for scrollable axis containers to ensure horizontal lines extend to the end
        if (clockTicksWrapper) {
            clockTicksWrapper.style.width = `${totalWidth}px`;
        }
        if (workIntervalTicksWrapper) {
            workIntervalTicksWrapper.style.width = `${totalWidth}px`;
        }
        const timeGridsWrapper = document.querySelector('.time-grids-wrapper');
        if (timeGridsWrapper) {
            timeGridsWrapper.style.width = `${totalWidth}px`;
        }

        if (clockSpacerWrapper) clockSpacerWrapper.style.gridTemplateColumns = '1fr';
        if (workIntervalSpacerWrapper) workIntervalSpacerWrapper.style.gridTemplateColumns = '1fr';

        if (numTotalTimelineSlots > 0) {
            const ticksGridColsStyle = `repeat(${numTotalTimelineSlots}, minmax(${ganttColumnMinWidth}, 1fr))`;
            if (clockTicksWrapper) clockTicksWrapper.style.gridTemplateColumns = ticksGridColsStyle;
            if (workIntervalTicksWrapper) workIntervalTicksWrapper.style.gridTemplateColumns = ticksGridColsStyle;
            timeGrids.forEach(grid => {
                grid.style.gridTemplateColumns = ticksGridColsStyle;
            });
        } else {
            const fallbackTicksGridColsStyle = `minmax(${ganttColumnMinWidth}, 1fr)`;
            if (clockTicksWrapper) clockTicksWrapper.style.gridTemplateColumns = fallbackTicksGridColsStyle;
            if (workIntervalTicksWrapper) workIntervalTicksWrapper.style.gridTemplateColumns = fallbackTicksGridColsStyle;
            timeGrids.forEach(grid => {
                grid.style.gridTemplateColumns = fallbackTicksGridColsStyle;
            });
        }

        timeGrids.forEach(grid => {
            grid.querySelectorAll('.break-column-fill, .work-column-border-carrier').forEach(el => el.remove());
            timelineSlots.forEach((slot, index) => {
                const isLastSlot = (index === numTotalTimelineSlots - 1);
                const contentGridLineBorderStyle = isLastSlot ? "none" : "1px solid #e0e0e0";
                let columnElement = null;
                if (slot.type !== 'work' && slot.type !== 'placeholder') {
                    columnElement = document.createElement('div');
                    columnElement.classList.add('break-column-fill', `break-type-${slot.type}`);
                } else {
                    columnElement = document.createElement('div');
                    columnElement.classList.add('work-column-border-carrier');
                }
                if (columnElement) {
                    columnElement.style.gridColumn = `${index + 1} / span 1`;
                    columnElement.style.borderRight = contentGridLineBorderStyle;

                    columnElement.dataset.columnIndex = index;
                    columnElement.addEventListener('mouseover', handleGanttCellHover);
                    columnElement.addEventListener('mouseout', handleGanttCellMouseOut);

                    grid.appendChild(columnElement);
                }
            });
        });

        function getTimelineSlotIndexForWorkStart(targetWorkMinutes) {
            if (totalWorkMinutes === 0 && timelineSlots.length > 0 && timelineSlots[0].type === 'placeholder') return 1;
            let cumulativeWorkTime = 0;
            for (let i = 0; i < timelineSlots.length; i++) {
                const slot = timelineSlots[i];
                if (slot.type === 'work') {
                    if (targetWorkMinutes >= cumulativeWorkTime && targetWorkMinutes < cumulativeWorkTime + slot.workTimeCovered) {
                        return i + 1;
                    }
                    cumulativeWorkTime += slot.workTimeCovered;
                }
                if (targetWorkMinutes === 0 && cumulativeWorkTime === 0 && slot.type === 'work') return i + 1;
            }
            if (targetWorkMinutes === totalWorkMinutes && totalWorkMinutes > 0) {
                let tempWorkTime = 0;
                for (let i = 0; i < timelineSlots.length; i++) {
                    if (timelineSlots[i].type === 'work') tempWorkTime += timelineSlots[i].workTimeCovered;
                    if (tempWorkTime === totalWorkMinutes) return i + 1;
                }
            }
            return numTotalTimelineSlots > 0 ? numTotalTimelineSlots : 1;
        }

        if (totalWorkMinutes > 0) {
            const allTechnicianGrids = timeGrids;
            allTechnicianGrids.forEach(grid => {
                const masterTaskBars = Array.from(grid.querySelectorAll('.task-bar[style*="display: none"]'));
                grid.querySelectorAll('.task-bar:not([style*="display: none"])').forEach(bar => bar.remove());

                masterTaskBars.forEach(masterBar => {
                    const assignmentStartWorkMinutes = parseFloat(masterBar.dataset.assignmentStart);
                    const assignmentDurationWorkMinutes = parseFloat(masterBar.dataset.assignmentDuration);
                    const taskIdText = masterBar.dataset.taskId;

                    if (assignmentDurationWorkMinutes === 0) {
                        const timelineSlotStartCssIndex = getTimelineSlotIndexForWorkStart(assignmentStartWorkMinutes);
                        const segmentDiv = masterBar.cloneNode(true);
                        segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                        segmentDiv.style.gridColumn = `${timelineSlotStartCssIndex} / span 1`;
                        segmentDiv.style.display = 'flex';
                        segmentDiv.classList.add('zero-duration');
                        grid.appendChild(segmentDiv);
                        return;
                    }

                    let workMinutesProcessedForTask = 0;
                    let currentSegmentStartTimelineSlot_0_based = -1;
                    let timelineSlotCursor_0_based = 0;
                    let cumulativeWorkTimeForCursorSearch = 0;
                    let initialCursorFound = false;

                    for (let i = 0; i < timelineSlots.length; i++) {
                        if (timelineSlots[i].type === 'work') {
                            if (assignmentStartWorkMinutes >= cumulativeWorkTimeForCursorSearch &&
                                assignmentStartWorkMinutes < cumulativeWorkTimeForCursorSearch + timelineSlots[i].workTimeCovered) {
                                timelineSlotCursor_0_based = i;
                                initialCursorFound = true;
                                break;
                            }
                            cumulativeWorkTimeForCursorSearch += timelineSlots[i].workTimeCovered;
                        }
                        if (assignmentStartWorkMinutes === 0 && cumulativeWorkTimeForCursorSearch === 0 && timelineSlots[i].type === 'work') {
                            timelineSlotCursor_0_based = i;
                            initialCursorFound = true;
                            break;
                        }
                    }
                    if (!initialCursorFound && assignmentStartWorkMinutes === totalWorkMinutes) {
                        for (let i = timelineSlots.length - 1; i >= 0; i--) {
                            if (timelineSlots[i].type === 'work') {
                                timelineSlotCursor_0_based = i;
                                initialCursorFound = true;
                                break;
                            }
                        }
                    }
                    if (!initialCursorFound) {
                        console.warn(`Could not find starting slot for task: ${masterBar.title}, start: ${assignmentStartWorkMinutes}`);
                        return;
                    }

                    let previousSlotWasBreakForSegmentStart = false;

                    while (workMinutesProcessedForTask < assignmentDurationWorkMinutes && timelineSlotCursor_0_based < timelineSlots.length) {
                        const currentSlot = timelineSlots[timelineSlotCursor_0_based];

                        if (currentSlot.type === 'work') {
                            if (currentSegmentStartTimelineSlot_0_based === -1) {
                                currentSegmentStartTimelineSlot_0_based = timelineSlotCursor_0_based;
                                if (timelineSlotCursor_0_based > 0 &&
                                    timelineSlots[timelineSlotCursor_0_based - 1].type !== 'work' &&
                                    timelineSlots[timelineSlotCursor_0_based - 1].type !== 'placeholder') {
                                    if (workMinutesProcessedForTask > 0) {
                                        previousSlotWasBreakForSegmentStart = true;
                                    } else {
                                        previousSlotWasBreakForSegmentStart = false;
                                    }
                                } else {
                                    previousSlotWasBreakForSegmentStart = false;
                                }
                            }

                            const remainingWorkForTask = assignmentDurationWorkMinutes - workMinutesProcessedForTask;
                            workMinutesProcessedForTask += Math.min(currentSlot.workTimeCovered, remainingWorkForTask);

                            if (workMinutesProcessedForTask >= assignmentDurationWorkMinutes || timelineSlotCursor_0_based === timelineSlots.length - 1) {
                                const segmentDiv = masterBar.cloneNode(true);
                                segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                                const startCol = currentSegmentStartTimelineSlot_0_based + 1;
                                const endColExclusive = timelineSlotCursor_0_based + 1 + 1;
                                segmentDiv.style.gridColumn = `${startCol} / ${endColExclusive}`;
                                segmentDiv.style.display = 'flex';
                                if (previousSlotWasBreakForSegmentStart) {
                                    segmentDiv.classList.add('task-segment-starts-after-break');
                                }
                                if (timelineSlotCursor_0_based < timelineSlots.length - 1 &&
                                    timelineSlots[timelineSlotCursor_0_based + 1].type !== 'work' &&
                                    timelineSlots[timelineSlotCursor_0_based + 1].type !== 'placeholder') {
                                    if (workMinutesProcessedForTask < assignmentDurationWorkMinutes) {
                                        segmentDiv.classList.add('task-segment-ends-before-break');
                                    }
                                }
                                grid.appendChild(segmentDiv);
                                currentSegmentStartTimelineSlot_0_based = -1;
                                previousSlotWasBreakForSegmentStart = false;
                                break;
                            }
                        } else {
                            if (currentSegmentStartTimelineSlot_0_based !== -1) {
                                const segmentDiv = masterBar.cloneNode(true);
                                segmentDiv.innerHTML = `<span>${taskIdText}</span>`;
                                const startCol = currentSegmentStartTimelineSlot_0_based + 1;
                                const endColExclusive = timelineSlotCursor_0_based + 1;
                                segmentDiv.style.gridColumn = `${startCol} / ${endColExclusive}`;
                                segmentDiv.style.display = 'flex';
                                if (previousSlotWasBreakForSegmentStart) {
                                    segmentDiv.classList.add('task-segment-starts-after-break');
                                }
                                segmentDiv.classList.add('task-segment-ends-before-break');
                                grid.appendChild(segmentDiv);
                                currentSegmentStartTimelineSlot_0_based = -1;
                                previousSlotWasBreakForSegmentStart = false;
                            }
                        }
                        timelineSlotCursor_0_based++;
                    }
                });
            });
        }
        setupGanttScrollSync();
    }

    // --- Technician Filter Modal Logic ---
    (function() {
        // Modal elements
        const filterBtn = document.getElementById('filter-button');
        const modal = document.getElementById('techFilterModal');
        const modalContent = document.getElementById('techFilterModalContent');
        const searchInput = document.getElementById('techFilterSearch');
        const checkboxesDiv = document.getElementById('techFilterCheckboxes');
        const applyBtn = document.getElementById('applyTechFilter');
        const clearBtn = document.getElementById('clearTechFilter');
        const taskSearchInput = document.getElementById('taskFilterSearch');
        const taskCheckboxesDiv = document.getElementById('taskFilterCheckboxes');
        // Tab elements
        const tabTechBtn = document.getElementById('tabTechBtn');
        const tabTaskBtn = document.getElementById('tabTaskBtn');
        const tabTechContent = document.getElementById('tabTechContent');
        const tabTaskContent = document.getElementById('tabTaskContent');

        // State
        let allTechs = [];
        let allTasks = [];
        let selectedTechs = null;
        let selectedTasks = null;
        let modalTempSelection = null;
        let modalTempTaskSelection = null;

        // Tab switching logic
        function switchTab(tab) {
            if (tab === 'tech') {
                tabTechBtn.classList.add('active');
                tabTaskBtn.classList.remove('active');
                tabTechContent.style.display = '';
                tabTaskContent.style.display = 'none';
                modalContent.classList.remove('tasks-tab-active');
            } else {
                tabTechBtn.classList.remove('active');
                tabTaskBtn.classList.add('active');
                tabTechContent.style.display = 'none';
                tabTaskContent.style.display = '';
                modalContent.classList.add('tasks-tab-active');
            }
        }
        tabTechBtn && tabTechBtn.addEventListener('click', () => switchTab('tech'));
        tabTaskBtn && tabTaskBtn.addEventListener('click', () => switchTab('task'));

        // Get available technicians from .technician-labels-wrapper
        function getAvailableTechnicians() {
            const labels = document.querySelectorAll('.technician-labels-wrapper .technician-label');
            return Array.from(labels).map(l => l.textContent.trim());
        }

        // Get available tasks from table (unique task names)
        function getAvailableTasks() {
            const rows = document.querySelectorAll('.task-table tbody tr:not(.section-header)');
            const taskNames = new Set();
            rows.forEach(row => {
                const cell = row.cells[1];
                if (cell) {
                    let name = cell.childNodes[0] && cell.childNodes[0].nodeType === 3 ? cell.childNodes[0].textContent.trim() : cell.textContent.trim();
                    if (name) taskNames.add(name);
                }
            });
            return Array.from(taskNames);
        }

        // Render checkboxes in modal, reflecting last selection or default (all unchecked)
        function renderTechCheckboxes(filter = "") {
            checkboxesDiv.innerHTML = "";
            allTechs.forEach(tech => {
                const label = document.createElement('label');
                label.style.display = tech.toLowerCase().includes(filter.toLowerCase()) ? 'flex' : 'none';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = tech;
                let checkedList = (modalTempSelection !== null) ? modalTempSelection : selectedTechs;
                cb.checked = Array.isArray(checkedList) && checkedList.includes(tech);
                cb.addEventListener('change', function() {
                    if (!Array.isArray(modalTempSelection)) modalTempSelection = [];
                    if (this.checked) {
                        if (!modalTempSelection.includes(tech)) modalTempSelection.push(tech);
                    } else {
                        modalTempSelection = modalTempSelection.filter(t => t !== tech);
                    }
                });
                label.appendChild(cb);
                label.appendChild(document.createTextNode(tech));
                checkboxesDiv.appendChild(label);
            });
        }

        // Render task checkboxes in modal
        function renderTaskCheckboxes(filter = "") {
            taskCheckboxesDiv.innerHTML = "";
            allTasks.forEach(task => {
                const label = document.createElement('label');
                label.style.display = task.toLowerCase().includes(filter.toLowerCase()) ? 'flex' : 'none';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = task;
                let checkedList = (modalTempTaskSelection !== null) ? modalTempTaskSelection : selectedTasks;
                cb.checked = Array.isArray(checkedList) && checkedList.includes(task);
                cb.addEventListener('change', function() {
                    if (!Array.isArray(modalTempTaskSelection)) modalTempTaskSelection = [];
                    if (this.checked) {
                        if (!modalTempTaskSelection.includes(task)) modalTempTaskSelection.push(task);
                    } else {
                        modalTempTaskSelection = modalTempTaskSelection.filter(t => t !== task);
                    }
                });
                // Task name: single line, ellipsis, unless very long
                const span = document.createElement('span');
                span.className = 'task-checkbox-label';
                span.textContent = task;
                if (task.length > 60) span.classList.add('long');
                label.appendChild(cb);
                label.appendChild(span);
                taskCheckboxesDiv.appendChild(label);
            });
        }

        // Open modal and position it below the filter button
        function openModal() {
            if (modal.style.display === 'flex') return;
            allTechs = getAvailableTechnicians();
            allTasks = getAvailableTasks();
            if (selectedTechs === null) {
                modalTempSelection = [];
            } else {
                modalTempSelection = selectedTechs.slice();
            }
            if (selectedTasks === null) {
                modalTempTaskSelection = [];
            } else {
                modalTempTaskSelection = selectedTasks.slice();
            }
            if (searchInput) searchInput.value = "";
            if (taskSearchInput) taskSearchInput.value = "";
            renderTechCheckboxes("");
            renderTaskCheckboxes("");
            switchTab('tech');
            modal.style.display = 'flex';
            setTimeout(() => {
                const btnRect = filterBtn.getBoundingClientRect();
                const scrollTop = window.scrollY || document.documentElement.scrollTop;
                const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
                modalContent.style.left = (btnRect.left + scrollLeft) + "px";
                modalContent.style.top = (btnRect.bottom + scrollTop) + "px";
            }, 0);
        }

        // Close modal (restore previous selection if not applied)
        function closeModal(restorePrevious = true) {
            if (restorePrevious) {
                modalTempSelection = null;
                modalTempTaskSelection = null;
            }
            modal.style.display = 'none';
        }

        // Apply filter
        function applyFilter() {
            const checkedTechs = Array.from(checkboxesDiv.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
            selectedTechs = checkedTechs.length === allTechs.length ? null : checkedTechs;
            const checkedTasks = Array.from(taskCheckboxesDiv.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
            selectedTasks = checkedTasks.length === allTasks.length ? null : checkedTasks;
            modalTempSelection = null;
            modalTempTaskSelection = null;
            applyTableFilter();
            applyGanttFilter();
            closeModal(false);
        }

        // Clear filter
        function clearFilter() {
            selectedTechs = null;
            selectedTasks = null;
            modalTempSelection = null;
            modalTempTaskSelection = null;
            applyTableFilter();
            applyGanttFilter();
            closeModal(false);
        }

        // Table filter: show only rows where at least one assigned technician is selected AND/OR task is selected
        function applyTableFilter() {
            const table = document.querySelector('.task-table');
            if (!table) return;
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                // Section headers always show
                if (row.classList.contains('section-header')) {
                    row.style.display = '';
                    return;
                }
                // Get assigned techs cell (5th index, th structure is fixed)
                const assignedCell = row.cells[4];
                const taskCell = row.cells[1];
                if (!assignedCell || !taskCell) { row.style.display = ''; return; }
                const assignedText = assignedCell.textContent || "";
                const taskName = taskCell.childNodes[0] && taskCell.childNodes[0].nodeType === 3 ? taskCell.childNodes[0].textContent.trim() : taskCell.textContent.trim();

                // If no filters, show all
                if ((!selectedTechs || selectedTechs.length === 0) && (!selectedTasks || selectedTasks.length === 0)) {
                    row.style.display = '';
                    return;
                }

                // Task filter
                let taskMatch = true;
                if (selectedTasks && selectedTasks.length > 0) {
                    taskMatch = selectedTasks.includes(taskName);
                }

                // Technician filter
                let techMatch = true;
                if (selectedTechs && selectedTechs.length > 0) {
                    const groupMatches = assignedText.match(/\[([^\]]+)\]/g) || [];
                    const assignedList = [];
                    groupMatches.forEach(group => {
                        group.replace(/[\[\]]/g, '').split('&').forEach(name => {
                            assignedList.push(name.trim());
                        });
                    });
                    techMatch = assignedList.some(name => selectedTechs.includes(name));
                }

                // AND logic: must match both if both filters are set
                row.style.display = (taskMatch && techMatch) ? '' : 'none';
            });
        }

        // Gantt filter: show only selected technician rows and their bars, or only those involved in selected tasks
        function applyGanttFilter() {
            const techLabels = document.querySelectorAll('.technician-labels-wrapper .technician-label');
            const timeGrids = document.querySelectorAll('.time-grids-wrapper .time-grid');
            // If task filter is active, show only techs involved in selected tasks
            let techsForTasks = null;
            if (selectedTasks && selectedTasks.length > 0) {
                // Find all techs assigned to selected tasks
                const table = document.querySelector('.task-table');
                const rows = table.querySelectorAll('tbody tr:not(.section-header)');
                const techSet = new Set();
                rows.forEach(row => {
                    const taskCell = row.cells[1];
                    const assignedCell = row.cells[4];
                    if (!taskCell || !assignedCell) return;
                    const taskName = taskCell.childNodes[0] && taskCell.childNodes[0].nodeType === 3 ? taskCell.childNodes[0].textContent.trim() : taskCell.textContent.trim();
                    if (selectedTasks.includes(taskName)) {
                        const assignedText = assignedCell.textContent || "";
                        const groupMatches = assignedText.match(/\[([^\]]+)\]/g) || [];
                        groupMatches.forEach(group => {
                            group.replace(/[\[\]]/g, '').split('&').forEach(name => {
                                techSet.add(name.trim());
                            });
                        });
                    }
                });
                techsForTasks = Array.from(techSet);
            }
            techLabels.forEach((label, idx) => {
                const tech = label.textContent.trim();
                let show = true;
                if (selectedTasks && selectedTasks.length > 0) {
                    show = techsForTasks.includes(tech);
                }
                if (selectedTechs && selectedTechs.length > 0) {
                    show = show && selectedTechs.includes(tech);
                }
                label.style.display = show ? '' : 'none';
                if (timeGrids[idx]) timeGrids[idx].style.display = show ? '' : 'none';
            });
        }

        // Search filter in modal
        searchInput && searchInput.addEventListener('input', function() {
            renderTechCheckboxes(this.value);
        });
        taskSearchInput && taskSearchInput.addEventListener('input', function() {
            renderTaskCheckboxes(this.value);
        });

        // Button events
        filterBtn && filterBtn.addEventListener('click', function() {
            if (modal.style.display === 'flex') {
                closeModal(true);
            } else {
                openModal();
            }
        });
        applyBtn && applyBtn.addEventListener('click', applyFilter);
        clearBtn && clearBtn.addEventListener('click', clearFilter);

        // Modal click outside closes modal and restores previous selection (cancel)
        modal && modal.addEventListener('mousedown', function(e) {
            if (e.target === modal) closeModal(true);
        });

        // On page load, no filter
        document.addEventListener('DOMContentLoaded', function() {
            allTechs = getAvailableTechnicians();
            allTasks = getAvailableTasks();
            selectedTechs = null;
            selectedTasks = null;
            modalTempSelection = null;
            modalTempTaskSelection = null;
        });
    })();
</script>
</body>
</html>
